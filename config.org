#+TITLE: config
#+STARTUP: fold

* general config
** localleader

#+BEGIN_SRC emacs-lisp
(setq doom-localleader-key ",")
#+END_SRC

# Stop complaining about non-prefix keys

# #+BEGIN_SRC emacs-lisp
# (general-auto-unbind-keys)
# #+END_SRC

** ui
*** theme

#+BEGIN_SRC emacs-lisp
(setq doom-theme 'doom-opera-light)
#+END_SRC

*** hl-line

Highlighting the current line is all nice and stuff but it looks off in org mode due to different sizes of headings.
Similarly in LaTeX due to sub/super -scripts.

#+BEGIN_SRC emacs-lisp
(remove-hook 'text-mode-hook #'hl-line-mode)
#+END_SRC

*** font

#+BEGIN_SRC emacs-lisp
;;(setq doom-font (font-spec :family "Terminus" :size 14))
;; (setq doom-font (font-spec :family "FiraCode-Regular" :size 24)
#+END_SRC

*** paren-mode
Highlight matching parentheses and such in every mode.

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

*** line number

Show line numbers to the left for better jumping.
(consider the ace jump package which shows a letter for every line for more efficient jumping)

#+BEGIN_SRC emacs-lisp
;; (setq display-line-numbers-type 'relative)
(setq display-line-numbers-type nil)
#+END_SRC

*** line truncation

stupid doom tries to truncate lines all the time which I don't like. This means that long lines go past the window end. When this is turned off they appear soft wrapped.

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines nil)
#+END_SRC

I have still no idea how this relates to ~visual-line-mode~. Seems to do the same...

*** opacity

Make emacs opaque (when running compton).

#+BEGIN_SRC emacs-lisp
;; (set-frame-parameter (selected-frame) 'alpha '(85 . 85))
;; (add-to-list 'default-frame-alist '(alpha . (85 . 85)))
#+END_SRC

*** modeline

#+BEGIN_SRC emacs-lisp
(after! doom-modeline
  ;; Disable unwanted modeline details.
  (size-indication-mode 0)

  ;; ;; Define a new default modeline.
  ;; (doom-modeline-def-modeline 'myline
  ;;   '(bar workspace-name window-number buffer-info remote-host)
  ;;   '(matches debug checker))

  ;; ;; Actually use the new settings.
  ;; (add-hook 'doom-modeline-mode-hook
  ;;   (lambda ()
  ;;     (doom-modeline-set-modeline 'myline 'default)))
  )
#+END_SRC
*** hl-todo

highlight keywords like TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW.

#+BEGIN_SRC emacs-lisp
(add-hook 'after-init-hook 'global-hl-todo-mode)
#+END_SRC

** general behavior

When splitting windows, put split on a reasonable side.

#+BEGIN_SRC emacs-lisp
(setq evil-split-window-below t
      evil-vsplit-window-right t)
#+END_SRC

I don't want aut-fill on by DEFAULT

#+BEGIN_SRC emacs-lisp
(remove-hook 'text-mode-hook #'auto-fill-mode)
#+END_SRC

When moving up or down. Start moving the text before the curser hits the border of the screen. Equivalent to vims ~scroll-off~.

#+BEGIN_SRC emacs-lisp
(setq scroll-margin 5)
#+END_SRC

** email

currently still using mutt. This tells Emacs to use mail mode when editing emails through mutt.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("/mutt" . mail-mode))
(add-to-list 'auto-mode-alist '("/neomutt" . mail-mode))
#+END_SRC

Turn on auto fill and break after specified number of chars

#+BEGIN_SRC emacs-lisp
(add-hook 'mail-mode-hook #'auto-fill-mode)
(add-hook 'mail-mode-hook
          (lambda ()
            (set-fill-column 72)))
#+END_SRC

This is copied from [[https://github.com/NicolasPetton/emacs.d/blob/3945786c31a17ac9caa8894109c231234956102f/hosts/blueberry/init-notmuch.el][github]] who took it from [[http://blog.binchen.org/posts/how-to-use-yasnippets-to-produce-email-templates-in-emacs.html][this blog]].

#+BEGIN_SRC emacs-lisp
;; Function to return first name of email recipient
;; Used by yasnippet
#+END_SRC

** dashboard

Show agenda for upcoming week and not just today.

#+BEGIN_SRC emacs-lisp
(setq show-week-agenda-p t)
#+END_SRC

** GTD

Keep everything out of your head, aka building a second brain.

#+BEGIN_SRC emacs-lisp
(defun ab/visit-references ()
  "go to my references file"
  (interactive)
  (find-file "~/org/Reference.org"))
#+END_SRC

** general nifty mappings

Most of the time I only have two windows open. Switching between should be easy.

#+BEGIN_SRC emacs-lisp
(map! "M-w" 'other-window)
#+END_SRC

~counsel-find-file~ lets you open a file in a new split, but with a weird mapping ~C-o j~.
I want a better one. However. this currently only works for ~find-file~ and not ~find-buffer~.


#+BEGIN_SRC emacs-lisp
(defun ivy-ffow-done ()
  "Exit the minibuffer, opening candidate in other window."
  (interactive)
  (ivy-set-action #'find-file-other-window)
  (ivy-done))

(map! :after counsel
      :map counsel-find-file-map
      "M-RET" #'ivy-ffow-done)
#+END_SRC
** recent files

When I kill emacs it doesn't remember which files I visited.
This makes MRU files rather useless. So let's save them regularly while running.
#+BEGIN_SRC emacs-lisp
(run-at-time (current-time) 300 'recentf-save-list)
#+END_SRC


* config file
** quick access

Configuring never stops. keep the config file close.

#+BEGIN_SRC emacs-lisp
(defun ab/visit-emacs-config ()
  "go to emacs config file"
  (interactive)
  (find-file "~/.doom.d/config.org"))

(map! :leader "e c" #'ab/visit-emacs-config)

(defun ab/visit-init ()
  "go to doom init file"
  (interactive)
  (find-file "~/.doom.d/init.el"))

(map! :leader "e i" #'ab/visit-init)
#+END_SRC

** reload
When regularly changing configs we also want to be able to use them without restarting emacs.

#+BEGIN_SRC emacs-lisp
(defun ab/reload-init-file ()
  "reload config file"
  (interactive)
  (load-file "~/.doom.d/config.el"))

(map! :leader "e r" 'ab/reload-init-file)
#+END_SRC

* vi
** config

Not quite sure what this does but it seems to fix some weird behavior with
visual lines

#+BEGIN_SRC emacs-lisp
(setq evil-respect-visual-line-mode nil)
#+END_SRC

If I don't set this, long lines are just cut off and the remainder is not displayed. Makes it impossible to edit such lines.

** leader

More vim functionality.

Set the leader key and some very basic keybindings.

#+BEGIN_SRC emacs-lisp
(map! :leader
      "q"   #'evil-quit
      "s h" #'evil-window-split
      "s v" #'evil-window-vsplit
      "e c" #'ab/visit-emacs-config
      "r"   #'ab/visit-references
      "x"   #'counsel-M-x ;; no need to press *meta*
      "w"   #'save-buffer)
#+END_SRC

** colemak settings :colemak:

*** new

Only this way I can use "N" in elfeed for example
#+BEGIN_SRC emacs-lisp
(after! evil
  (define-key evil-visual-state-map "l" evil-inner-text-objects-map)
  (define-key evil-operator-state-map "l" evil-inner-text-objects-map)
  (map! :n "l" 'evil-insert
        :n "L" 'evil-insert-line
        :nv "h" 'evil-backward-char
        :nv "i" 'evil-forward-char
        :nv "n" 'evil-next-visual-line
        :nv "e" 'evil-previous-visual-line
        :nv "k" 'evil-ex-search-next
        :nv "K" 'evil-ex-search-previous
        :n "N" 'evil-join
        ;; :vo "l" evil-inner-text-objects-map
        :nvo "j" 'evil-forward-word-end
        :nvo "J" 'evil-forward-WORD-end))

(after! magit
  (map! :map magit-mode-map
        :n "n" 'magit-next-line
        :n "e" 'magit-previous-line))

(map! :map org-agenda-mode-map
      :m "n" 'org-agenda-next-line
      :m "e" 'org-agenda-previous-line
      )
#+END_SRC

This is an adaptation of [[https://github.com/doomemacs/doomemacs/issues/783][this issue]].

*** old

This does not allow me to remap for example "N" in elfeed-show-mode

Evil for colemak keyboard layout. Adapted from the [[https://github.com/wbolster/evil-colemak-basics][evil-colemak-basics]] package. For some reason trying to defining everything manually via ~evil-define-key~ or ~define-key evil-motion-state-map~ gave me trouble with ~'inner-text-objects~ and more..

#+BEGIN_SRC emacs-lisp
;; (defgroup evil-colemak nil
;;   "Basic key rebindings for evil-mode with the Colemak keyboard layout."
;;   :prefix "evil-colemak-"
;;   :group 'evil)

;; (defcustom evil-colemak-char-jump-commands nil
;;   "The set of commands to use for jumping to characters.
;;         By default, the built-in evil commands evil-find-char (and
;;         variations) are used"
;;   :group 'evil-colemak
;;   :type '(choice (const :tag "default" nil)))

;; (defun evil-colemak--make-keymap ()
;;   "Initialise the keymap baset on the current configuration."
;;   (let ((keymap (make-sparse-keymap)))
;;     (evil-define-key '(motion normal visual) keymap
;;       "n" 'evil-next-visual-line
;;       ;; "gn" 'evil-next-visual-line
;;       ;; "gN" 'evil-next-visual-line
;;       "e" 'evil-previous-visual-line
;;       ;; "ge" 'evil-previous-visual-line
;;       "E" 'evil-lookup
;;       "i" 'evil-forward-char
;;       "I" 'evil-end-of-line
;;       "j" 'evil-forward-word-end
;;       "J" 'evil-forward-WORD-end
;;       "gj" 'evil-backward-word-end
;;       "gJ" 'evil-backward-WORD-end
;;       "k" 'evil-ex-search-next       ;; doom needs an "ex"
;;       "K" 'evil-ex-search-previous   ;; doom needs an "ex"
;;       "gk" 'evil-next-match
;;       "gK" 'evil-previous-match
;;       "zi" 'evil-scroll-column-right
;;       "zI" 'evil-scroll-right)
;;     (evil-define-key '(normal visual) keymap
;;       "N" 'evil-join
;;       "gN" 'evil-join-whitespace)
;;     (evil-define-key 'normal keymap
;;       "l" 'evil-insert
;;       "L" 'evil-insert-line)
;;     (evil-define-key 'visual keymap
;;       "L" 'evil-insert)
;;     (evil-define-key '(visual operator) keymap
;;       "l" evil-inner-text-objects-map)
;;     (evil-define-key 'operator keymap
;;       "i" 'evil-forward-char)
;;     keymap))

;; (defvar evil-colemak-keymap
;;   (evil-colemak--make-keymap)
;;   "Keymap for evil-colemak-mode.")

;; (defun evil-colemak-refresh-keymap ()
;;   "Refresh the keymap using the current configuration."
;;   (setq evil-colemak-keymap (evil-colemak--make-keymap)))

;;       ;;;###autoload
;; (define-minor-mode evil-colemak-mode
;;   "Minor mode with evil-mode enhancements for the Colemak keyboard layout."
;;   :keymap evil-colemak-keymap
;;   :lighter " hnei")

;;       ;;;###autoload
;; (define-globalized-minor-mode global-evil-colemak-mode
;;   evil-colemak-mode
;;   (lambda () (evil-colemak-mode t))
;;   "Global minor mode with evil-mode enhancements for the Colemak keyboard layout.")

;; (after! evil
;;   (global-evil-colemak-mode))
#+END_SRC
*** windows

Switching windows also relies on the `hjkl` motions. So make it colemak friendly.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil-maps
  (define-key evil-window-map "n" 'evil-window-down)
  (define-key evil-window-map "e" 'evil-window-up)
  (define-key evil-window-map "i" 'evil-window-right))
#+END_SRC

*** org-mode

~evil-org-mode~ overrides some of my colemak settings. Override them again afterwards.

#+BEGIN_SRC emacs-lisp
(after! evil
  (map! :map evil-org-mode-map
        :mnvo "i" #'evil-forward-char
        :mnvo "I" #'evil-end-of-line))

(after! evil-org
  (map! :map evil-org-mode-map
        :mnvo "i" #'evil-forward-char
        :mnvo "I" #'evil-org-end-of-line))

;; (after! evil
;;   (map! :map evil-tex-mode-map
;;         :mnvo "i" #'evil-forward-char
;;         :mnvo "I" #'evil-org-end-of-line))
;; (add-hook 'evil-tex-mode-hook (lambda () (global-evil-colemak-mode)))
;; (add-hook 'LaTeX-mode-hook (lambda () (global-evil-colemak-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (evil-collection-translate-key nil 'evil-motion-state-map
;;   ;; colemak hnei is qwerty hjkl
;;   "n" "j"
;;   "e" "k"
;;   "i" "l"
;;   ;; add back nei
;;   "j" "e"
;;   "k" "n"
;;   "l" "i")
;; (defun my-hjkl-rotation (_mode mode-keymaps &rest _rest)
;;   (evil-collection-translate-key 'normal mode-keymaps
;;     "n" "j"
;;     "e" "k"
;;     "i" "l"
;;     "j" "e"
;;     "k" "n"
;;     "l" "i"))

;; ;; called after evil-collection makes its keybindings
;; (add-hook 'evil-collection-setup-hook #'my-hjkl-rotation)

;; (evil-collection-init)
#+END_SRC
Different setup



** ~matchit~

Extend the ~%~ functionality to jump between tags such as LaTeX ~\begin{...}~ and ~\end{...}~. This is sooo important!!!

#+BEGIN_SRC emacs-lisp
(after! evil
  (global-evil-matchit-mode))
#+END_SRC

** paragraph

The function ~evil-forward-paragraph~ (default bound to ~}~) reuses Emacs'
~forward-paragraph~ which is different in every major mode. I've gotten used to
vim's behaviour of just going to the next empty line. This chunk makes evil use
the default paragraph. This makes so much more sense considering commands like
~y a p~ (read "yank around paragraph") treats paragraphs always the way I
want them. Got this from [[https://emacs.stackexchange.com/questions/38596/make-evil-paragraphs-behave-like-vim-paragraphs][here]].

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  (defadvice forward-evil-paragraph (around default-values activate)
    (let ((paragraph-start (default-value 'paragraph-start))
          (paragraph-separate (default-value 'paragraph-separate)))
      ad-do-it)))
#+END_SRC
** custom :colemak:

Custom mappings.

#+BEGIN_SRC emacs-lisp
(after! evil
  (map! :mnv "H" #'evil-first-non-blank
        :mnv "I" #'evil-end-of-line
        :mnv "E" #'+lookup/definition
        :leader "l" 'avy-goto-line))

(after! evil-org
  (map! :mnv "H" #'evil-first-non-blank
        :mnv "I" #'evil-end-of-line
        :mnv "E" #'+lookup/definition
        :leader "l" 'avy-goto-line))

(after! evil-snipe
  (map! :leader "/" #'evil-avy-goto-char-2))
#+END_SRC

* buffer handling

Switch back and forth between the two MRU buffers.

#+BEGIN_SRC emacs-lisp
(defun ab/switch-to-previous-buffer ()
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(map! :leader "SPC" #'ab/switch-to-previous-buffer)
#+END_SRC

* org mode

#+begin_center
=Your life in plain text=
#+end_center

** config

Load org-mode plus some standard keybindings.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq +org-roam-auto-backlinks-buffer t
        org-hide-emphasis-markers nil            ;; I want those
        org-return-follows-link t
        ;; the follow two do not work for some reason and others seem to have the same problem
        org-agenda-skip-scheduled-if-done t      ;; don't show in agenda if done
        org-agenda-skip-deadline-if-done  t
        ;;
        org-agenda-compact-blocks t
        org-reverse-note-order t                 ;; add new headings on top
        org-tags-column 0                        ;; position of tags (0 is to the left)
        org-log-done 'time                       ;; add time when task was completed
        org-todo-keywords '((sequence "TODO(t)"
                                      "NEXT(n)"
                                      "WAITING(w)"
                                      "|"
                                      "DONE(d)")
                            ;; research specific
                            (sequence "TODO(t)"
                                      "DIDN'T SUCCEED(s)"
                                      "|"
                                      "DOESN'T WORK(x)"
                                      "TOO HARD(h)"
                                      "DONE(d)"))

        org-todo-keyword-faces '(("WAITING" :foreground "#8FBCBB" :weight bold)
                                 ("NEXT" :foreground "#ff9800" :weight bold)
                                 )))

(map! :leader
      "o s l" 'org-store-link
      "o s n" 'default/org-notes-search
      ;; "o a" 'org-agenda
      "o c" 'org-capture)
#+END_SRC

There is also ~org-agenda-skip-function-global '(org-agenda-skip-entry-if 'todo 'done)~ but I don't this so I cannot see done task of the day.

Line numbers in org mode are useless.

#+BEGIN_SRC emacs-lisp
(defun ab/disable-line-numbers ()
  (interactive)
  (display-line-numbers-mode -1))

(add-hook 'org-mode-hook #'ab/disable-line-numbers)
#+END_SRC

No instant spell checking.. Takes too long.
#+BEGIN_SRC emacs-lisp
(after! org
  (setq-hook! 'org-mode-hook +flyspell-immediately nil))
#+END_SRC

I have some reoccurring tasks/chores. These will be shown in the agenda multiple times. This is supposed to show them only once.
#+BEGIN_SRC emacs-lisp
(setq org-agenda-show-future-repeats 'next)
#+END_SRC

** agenda
Create a custom view.

I want a go-to GTD style agenda view with:
- scheduled tasks for the day
- deadlines
- what to work on next
- checking if the inbox is empty

This setup is from here: https://www.labri.fr/perso/nrougier/GTD/index.html#org67cf0bc

#+BEGIN_SRC emacs-lisp
(setq org-agenda-format-date
          (lambda (date)
            (concat "  " (org-agenda-format-date-aligned date))))

(setq org-agenda-custom-commands
      '(("W" "Weekly Review"
         ((agenda "" ((org-agenda-span 14))); review upcoming deadlines and appointments
                                           ; type "l" in the agenda to review logged items
          (todo "PROJECT") ; review all projects (assuming you use todo keywords to designate projects)
          (todo "MAYBE") ; review someday/maybe items
          (todo "WAITING"))) ; review waiting items

         ;; ...other commands here
        ("n" todo "NEXT")

        ("g" "Get Things Done (GTD)"
         ((todo "LALA" ;; dummy item just so I can get a header for the deadlines (see next item)
                ((org-agenda-overriding-header "\nScheduled\n")))
          (agenda ""
                  ((org-agenda-skip-function
                    '(org-agenda-skip-entry-if 'deadline 'done))   ;; deadlines go in a different "section"
                   (org-agenda-show-all-dates nil)
                   (org-agenda-prefix-format "    [%e]  ")
                   (org-agenda-overriding-header "\nScheduled\n")  ;; not working
                   (org-deadline-warning-days 0)))
          ;; (todo "LALA"
          ;;       ((org-agenda-overriding-header "\nUpcoming\n")))
          ;; (agenda ""
          ;;         (
          ;;          ;; (org-agenda-span 1)
          ;;          (org-agenda-skip-function
          ;;           '(org-agenda-skip-entry-if 'deadline))
          ;;          (org-agenda-show-all-dates nil)
          ;;          (org-agenda-overriding-header "\nScheduled\n")  ;; not working
          ;;          (org-deadline-warning-days 0)))
          (todo "NEXT"
                ((org-agenda-skip-function
                  '(org-agenda-skip-entry-if 'deadline))
                 (org-agenda-prefix-format "  %i %-12:c [%e] %s ")
                 (org-agenda-overriding-header "\nNext Action\n")))

          (todo "LALA" ;; dummy item just so I can get a header for the deadlines (see next item)
                ((org-agenda-overriding-header "\nDeadlines\n")))
          (agenda ""
                  ((org-agenda-entry-types '(:deadline))
                   (org-agenda-show-all-dates nil)
                   (org-agenda-prefix-format " %i [%e] %s ")
                   (org-agenda-overriding-header "\nDeadlines\n")  ;; not working
                   (org-deadline-warning-days 0)))
          (tags "inbox"
                     ((org-agenda-prefix-format "  [%e]  ")
                      (org-agenda-overriding-header "\nInbox\n")))
          (tags "CLOSED>=\"<today>\""
                ((org-agenda-overriding-header "\nCompleted today\n")))))

        ))
#+END_SRC

For some reason ~(org-agenda-overriding-header)~ is not working on ~agenda~ items...

The weekly review is taken from [[https://orgmode.org/worg/org-tutorials/org-custom-agenda-commands.html][orgmode.org]]

Quick access to GTD view.
#+BEGIN_SRC emacs-lisp
(map! :leader "o g" (lambda ()
             (interactive)
             (org-agenda nil "g")))
#+END_SRC

** appearance

Title size.
#+BEGIN_SRC emacs-lisp
(after! org
  (custom-theme-set-faces
   'user
   `(org-document-title ((t (:height 1.5 :underline nil))))))
#+END_SRC

configure the symbol for stuff hidden after heading.
#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-ellipsis " ..."))
#+END_SRC

** structure and files

Tell emacs where I store my org stuff.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-directory "~/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  (setq org-inbox-file "~/org/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  ;; (setq org-inbox-file "~/Dropbox/GTD/inbox.org")
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s")))
#+END_SRC

This sets the file(s) from which the agenda is derived.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-agenda-files (list org-index-file
                               org-inbox-file
                               (org-file-path "archive.org") ;; I want to see also completed items
                               (org-file-path "Reference.org"))))
#+END_SRC

By default org-mode does super ugly truncation of long lines (apparently because of tables). I want line wrapping, however.

#+BEGIN_SRC emacs-lisp
(after! org (setq org-startup-truncated 'nil))
#+END_SRC

By default org-agenda only shows one week starting last Monday. I want two weeks starting today.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-agenda-span 14)
  (setq org-agenda-start-on-weekday nil)
  (setq org-agenda-start-day "-0d"))
#+END_SRC
** keybindings
*** structure editing

Org structure editing made easy/mnemonic.

#+BEGIN_SRC emacs-lisp
(after! org
  (map! :map org-mode-map
        :localleader
        "w" 'widen                   ;; show everythig
        "n" 'org-toggle-narrow-to-subtree)  ;; show only what's within heading
)
#+END_SRC

~org-narrow-subtree~ shows only a single heading (the heading of the current subtree). I need more context!! I want to see which hierarchy this heading belongs to. Taken from [[https://emacs.stackexchange.com/questions/29304/how-to-show-all-contents-of-current-subtree-and-fold-all-the-other-subtrees][stackexchange]].

#+BEGIN_SRC emacs-lisp
(defun ab/org-show-just-me (&rest _)
  "Fold all other trees, then show entire current subtree."
  (interactive)
  (org-overview)
  (org-reveal)
  (org-show-subtree))

(map! :map org-mode-map
      :localleader "N" 'ab/org-show-just-me)            ;; Mnemonic: narrow
#+END_SRC
What I don't like is that this also shows all heading of level 1 and all headings of the same level as current heading.

Use vim instead of arrows.
#+BEGIN_SRC emacs-lisp
(map! :map org-mode-map
      "M-e" #'org-metaup
      "M-i" #'org-metaright
      "M-n" #'org-metadown)
#+END_SRC

Use ~o~ instead of ~RET~ for new headings/list-items.
#+BEGIN_SRC emacs-lisp
(after! org
  (map! :map org-mode-map
        "M-o" '+org/insert-item-below
        "M-O" '+org/insert-item-above))
#+END_SRC

*** index file :WIP:

copy tasks/notes from mobile.

#+BEGIN_SRC emacs-lisp
;; (defun ab/copy-tasks-from-mobile
;;   "Copy tasks I added from Orgzly"
;;   (interactive)
;;   (when (file-exists-p org-inbox-file)
;;     (save-excursion
;;       (find-file org-inbox-file)
;;       (org-refile org-index-file)))
;;     )
#+END_SRC

Quickly access the org index file.

#+BEGIN_SRC emacs-lisp
(defun ab/open-index-file ()
  "Open the master org TODO list."
  (interactive)
  ;; (find-file org-inbox-file)
  ;; (split-window-horizontally)
  (find-file org-index-file)
  )

(map! :leader "i" #'ab/open-index-file)
(map! :leader "o i" #'ab/open-index-file)
#+END_SRC

*** navigation

Mnemonic navigation.

#+BEGIN_SRC emacs-lisp
(map! :map org-mode-map
        :localleader
        "g h" 'org-previous-visible-heading      ;; Go Heading of current section
        "g e" 'org-previous-visible-heading      ;; Go e (= colemak up)
        "g u" 'outline-up-heading                ;; Go Up in hierarchy
        "g n" 'org-next-visible-heading          ;; Go Next heading
        )
#+END_SRC

The above motions are easy to remember but feel clunky when trying to go more then one heading up or down (this is probably an antipattern anyways..). Either way, here are some single key mappings.
I don't use ~(~ or ~)~ in evil mode too much anyways.

#+BEGIN_SRC emacs-lisp
(map! :map org-mode-map
   :n "]" 'org-next-visible-heading
   :n "[" 'org-previous-visible-heading)
#+END_SRC

*** archiving

When I archive something it is usually also done. By default however archiving doesn't change the todo-state.
So let's have a command that does both.

#+BEGIN_SRC emacs-lisp
(defun ab/mark-done-and-archive ()
  "Mark the state of an org-mode item as DONE and archive it."
  (interactive)
  (org-todo 'done)
  (org-archive-subtree))

(map! :map org-mode-map :leader "o d" 'ab/mark-done-and-archive)
#+END_SRC
*** links

#+BEGIN_SRC emacs-lisp
(defun ab/insert-url-as-org-link-fancy ()
  "If there's a URL on the clipboard, insert it as an org-mode
link in the form of [[url][*]], and leave point at *."
  (interactive)
  (let ((link (substring-no-properties (x-get-selection 'CLIPBOARD)))
        (url  "\\(http[s]?://\\|www\\.\\)"))
    (save-match-data
      (if (string-match url link)
          (progn
            (insert (concat "[[" link "][]]"))
            (backward-char 2)
            (evil-insert)
            )

        (error "No URL on the clipboard")))))

(map! :map org-mode-map :localleader "l u" 'ab/insert-url-as-org-link-fancy)
#+END_SRC

*** general

Show all todos with state ~NEXT~.

#+BEGIN_SRC emacs-lisp
(defun ab/open-agenda-next-tasks  ()
  "show all tasks marked as NEXT"
  (interactive)
  (org-tags-view t "/NEXT"))

(map! :leader "o n" 'ab/open-agenda-next-tasks)
#+END_SRC

** org capture

Keep everything out of your head! Has to be as convenient as possible.

*** config

Always start in insert mode when capturing.

#+BEGIN_SRC emacs-lisp
(after! org
  (add-hook 'org-capture-mode-hook 'evil-insert-state))
#+END_SRC

When refiling I want to be able to refile also to a sub(sub...)headings.
Default only allows for ~level 3~ or so.

#+BEGIN_SRC emacs-lisp
(after! org
 (setq org-refile-targets '((nil :maxlevel . 6)
                            (org-agenda-files :maxlevel . 6))))
;; (setq org-completion-use-ido t)

;; (setq org-outline-path-complete-in-steps nil) ;; has to be nil for ido to work
;; (setq org-refile-use-outline-path 'file)
#+END_SRC

This seems to work in doom out of the box.

*** templates

Templates for capturing. Also, ~%a~ expands to a link to the file (and position) from which =org-capture= was called. I think =%i= is active region. Another nice feature is ~%^{Name}~ prompts for name. This probably makes sense for titles or something because I tend to put too much next to the asterics and too little text underneath..
Check [[https://orgmode.org/manual/Template-expansion.html#Template-expansion][here]] for documentation.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-capture-templates
        '(("l" "Link (with todo)" entry
           ;; (file+headline org-index-file "Inbox")
           (file org-inbox-file)
           "*** TODO %^{task}
:properties:
:context: %A
:file: %F
:end:
%?\n")

          ("n" "Note"  entry
           ;; (file+headline org-index-file "Inbox")
           (file org-inbox-file)
           "*** %?\n\n")

          ;; no need for a separate `org-roam-capture` function or key-combo
          ("r" "org-roam" entry
           (function org-roam-capture))

          ("t" "Todo" entry
           ;; (file+headline org-index-file "Inbox")
           (file org-inbox-file)
           "*** TODO %?
:properties:
:created: %U
:end:"))))
#+END_SRC

Scheduled task with notifier.

#+BEGIN_SRC emacs-lisp
(after! org (add-to-list 'org-capture-templates
          '("s" "Scheduled task"  entry
           ;; (file+headline org-index-file "Inbox")
           (file org-inbox-file)
           "*** TODO %^{task}
SCHEDULED: %^t
:properties:
:created: %U
:WILD_NOTIFIER_NOTIFY_BEFORE: %^{notify when?} 30 5
:end:
%?\n
")))
#+END_SRC

*** capture anywhere

Call org-capture from anywhere (system wide). Code taken from [[https://www.reddit.com/r/emacs/comments/74gkeq/system_wide_org_capture/][reddit.]]

#+BEGIN_SRC emacs-lisp
(after! org
  (defadvice org-switch-to-buffer-other-window
      (after supress-window-splitting activate)
    "Delete the extra window if we're in a capture frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-other-windows)))

  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (defun activate-capture-frame ()
    "run org-capture in capture frame"
    (select-frame-by-name "capture")
    (switch-to-buffer (get-buffer-create "*scratch*"))
    (org-capture)))
#+END_SRC

The above code, together with the follow shell command does the job.

# #+BEGIN_SRC shell :eval no
# emacsclient -c -F '(quote (name . "capture"))' -e '(activate-capture-frame)'
# #+END_SRC

For this to work the emacs server hast to be running. (But only do if it's not yet running.)

#+BEGIN_SRC emacs-lisp
;; (load "server")
;; (unless (server-running-p) (server-start))
#+END_SRC

The other option would be to start emacs as a daemon. can even be started with systemd, see [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html][link]].

When calling org capture from outside emacs it uses ~counsel-org-capture~ which has this weird feature that it uses fuzzy matching to determine the template which is unnecessary since all templates have a one-letter abbreviation. Solution: override counsel capture with regular capture.

#+BEGIN_SRC emacs-lisp
(after! org
  (advice-add 'counsel-org-capture :override #'org-capture))
#+END_SRC

** org-notifications

I want notifications for scheduled headlines. Unfortunately ~org-alert~ only has the capability to notify every N minutes and doesn't consider the time an item is scheduled for.

This package sends a notification every x minutes before schedule and even allows for multiple notifications per TODO.

#+BEGIN_SRC emacs-lisp
(after! org
  :init
  (add-hook 'org-mode-hook #'org-wild-notifier-mode t)
  :config
  (setq org-wild-notifier-alert-time 15
        ;; use dunst for system wide notifications
        alert-default-style 'libnotify))

#+END_SRC

If the package is deferred to ~:after org~ the hook won't work.
Not quite happy with this solution. If it's not deferred that org is loaded at startup (which is slow..)

** opening pdfs

I want pdfs to be opened in an external pdf viewer.

#+BEGIN_SRC emacs-lisp
(after! org
  (add-hook 'org-mode-hook
            '(lambda ()
               (delete '("\\.pdf\\'" . default) org-file-apps)
               (add-to-list 'org-file-apps '("\\.pdf\\'" . "zathura %s")))))
#+END_SRC
** org-noter

Keep plain text notes alongside my pdfs.

#+BEGIN_SRC emacs-lisp
(setq org-noter-always-create-frame nil)
(setq org-noter-notes-search-path org-roam-directory)
#+END_SRC

** org-roam

#+BEGIN_SRC emacs-lisp
(setq org-roam-directory "~/org/roam")
#+END_SRC

I keep my roam files in dropbox folder which causes problems with the database on different machines. Easiest solution is to just keep the database outside the synced folder. The location is chosen arbitrary
#+BEGIN_SRC emacs-lisp
(setq org-roam-db-location "~/.cache/oarg-roam.db")
#+END_SRC


*** deft

I only use ~deft~ for org-roam notes so the config goes here.
#+BEGIN_SRC emacs-lisp
(setq deft-recursive t)
(setq deft-use-filter-string-for-filename t)
(setq deft-default-extension "org")
(setq deft-directory org-roam-directory)
#+END_SRC

Some obscure solution the get a reasonable preview taken from [[https://github.com/jrblevin/deft/issues/75#issuecomment-905031872][this github issue]].

#+BEGIN_SRC emacs-lisp
(defun cm/deft-parse-title (file contents)
  "Parse the given FILE and CONTENTS and determine the title.
  If `deft-use-filename-as-title' is nil, the title is taken to
  be the first non-empty line of the FILE.  Else the base name of the FILE is
  used as title."
  (let ((begin (string-match "^#\\+[tT][iI][tT][lL][eE]: .*$" contents)))
    (if begin
        (string-trim (substring contents begin (match-end 0)) "#\\+[tT][iI][tT][lL][eE]: *" "[\n\t ]+")
      (deft-base-filename file))))

  (advice-add 'deft-parse-title :override #'cm/deft-parse-title)

  (setq deft-strip-summary-regexp
      (concat "\\("
              "[\n\t]" ;; blank
              "\\|^#\\+[[:alpha:]_]+:.*$" ;; org-mode metadata
              "\\|^:properties:\n\\(.+\n\\)+:end:\n"
              "\\|^:PROPERTIES:\n\\(.+\n\\)+:END:\n"
              "\\)"))
#+END_SRC

*** capture templates

Extra properties for org-roam capture.

#+BEGIN_SRC emacs-lisp
(setq org-roam-capture-templates
      '(
        ("b" "bibliography reference" plain "%?"
         :target
         (file+head "${citekey}.org"
                    ":properties:
:author: ${author-or-editor}
:#+created: %(org-insert-time-stamp (current-time) t t)
:#+last_modified: %(org-insert-time-stamp (current-time) t t)
:end:
#+title: ${title}\n
")
         :unnarrowed t)

        ("d" "default" plain "%?"
         :target
         (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                    ":properties:
:#+created: %(org-insert-time-stamp (current-time) t t)
:#+last_modified: %(org-insert-time-stamp (current-time) t t)
:end:
#+title: ${title}
")
         :unnarrowed t)))
#+END_SRC

*** timestamps

Make available ‘#+last_modified’, an automatically updated timestamp, for org files. This src block can probably be moved at some point to the general org-config, but currently I only use the timestamp feature for ~ORB~.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq time-stamp-active t
        time-stamp-line-limit 10
        time-stamp-start "#\\+last_modified: [\t]*"
        time-stamp-end "$"
        time-stamp-format "\[%Y-%02m-%02d %02H:%02M\]"
        )
  (add-hook 'write-file-hooks 'time-stamp)
  )
#+END_SRC
*** org-roam-bibtex

Combines ~org-roam~, with ~(helm/ivy)-bibtex~ and ~org-ref~.

Only for activating org-roam bibtex.
#+BEGIN_SRC emacs-lisp
(use-package! org-roam-bibtex
  :after org-roam
  :config
  (require 'org-ref)) ; optional: if Org Ref is not loaded anywhere else, load it here

(after! org-roam
  (org-roam-bibtex-mode))
#+END_SRC


Currently I only need one template, but I want more properties.

#+BEGIN_SRC emacs-lisp
(setq orb-preformat-keywords
      '("citekey" "title" "url" "author-or-editor" "keywords" "file")
      orb-process-file-keyword t
      orb-file-field-extensions '("pdf"))

;; (setq orb-templates
;;       '(("r" "ref" plain "%?"
;;          :target
;;          (file+head "${citekey}.org" "#+title: ${title}\n"))))
;; #+roam_key: ${ref}
;; #+author: ${author-or-editor}
;; #+created: %(org-insert-time-stamp (current-time) t t)
;; #+last_modified: %(org-insert-time-stamp (current-time) t t)

;; - tags ::
;; - keywords :: ${keywords}

;; \n* ${title}
;; :properties:
;; :citekey: ${citekey}
;; :author: ${author-or-editor}
;; :noter_document: ${file}
;; :end:"))))

#+END_SRC

The later part provide integration with org-noter, see [[https://github.com/org-roam/org-roam-bibtex/blob/8d80bf980776df6ead53e917eb482ec8e309a1d7/doc/orb-manual.org][orb github]].


** org-timer

First we need to "unmap" leader o t which by default is `+vterm/toggle`.

#+BEGIN_SRC emacs-lisp
(map! :leader "o t" nil)

(map! :leader
      :desc "open terminal here" "o t h" #'+vterm/toggle
      :desc "set timer" "o t s" #'org-timer-set-timer
      :desc "pause or continue" "o t p" #'org-timer-pause-or-continue)
#+END_SRC


* LaTeX
** general

#+BEGIN_SRC emacs-lisp
(after! latex
  (setq tex-fontify-script t
        ;; automatically put braces after ^ and _
        TeX-electric-sub-and-superscript nil
        ;; stop asking if I want to save
        TeX-save-query nil
        ;; auto insert second dollar sign
        ;; TeX-electric-math (cons "$" "$")
        ;; don't show ^ or _ for scripts
        font-latex-fontify-script t)

  ;; use Zathura as pdf viewer
  (setq TeX-view-program-selection '((output-pdf "Zathura"))
        TeX-source-correlate-start-server t))

;; Ensure that synctex works and the pdf is updated.
(after! latex
  (add-hook! 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer))

#+END_SRC

Do not spellcheck latex documents when opened, this takes a lot of time.
#+BEGIN_SRC emacs-lisp
(after! tex
  (setq-hook! 'TeX-mode-hook +flyspell-immediately nil))
#+END_SRC

experimental
#+BEGIN_SRC emacs-lisp
(defun ab/run-latexmk ()
  "Run LatexMk without asking for confirmation. Saves the master file (and children)."
  (interactive)
  (TeX-save-document (TeX-master-file))
  (TeX-command "LatexMk" #'TeX-master-file -1))
#+END_SRC

** keybindings

LaTeX specific keybindings.

#+BEGIN_SRC emacs-lisp
(map! :map LaTeX-mode-map
      :localleader
      :desc "Compile"     ","  #'TeX-command-run-all
      :desc "Fold"        "z"  #'TeX-fold-buffer
      :desc "ToC"         "t"  #'reftex-toc
      :desc "next err"    "n"  #'TeX-next-error
      :desc "View"        "v"  #'TeX-view
      :desc "count words" "c"  #'tex-count-words
)
#+END_SRC
** company

Enable company-bibtex for completion.

#+BEGIN_SRC emacs-lisp
(add-to-list 'company-backends 'company-bibtex)
(setq company-bibtex-bibliography
  '("~/academia/bibliography/bibfile.bib"))
#+END_SRC

** matchit

add some LaTeX keywords which are not included by ~evil-matchit~ by default.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'evil-matchit-latex
  '(progn
     (push '("langle" nil "rangle") evilmi-latex-match-tags)))
     ;; (push '(("unless" "if") ("elsif" "else") "end"))) evilmi-latex-match-tags)
#+END_SRC

** ~evil-tex~

This package introduces new text objects e.g. ~ci$~ now changes inside $...$.
Always use it when editing tex files:

#+BEGIN_SRC emacs-lisp
(add-hook 'TeX-mode-hook (lambda () (interactive) (evil-tex-mode 1)))

#+END_SRC

evil-tex has very nice toggle commands but I can't remember them.

#+BEGIN_SRC emacs-lisp
(map! :map LaTeX-mode-map
      :localleader :desc "toggle delimiter" "d"  #'evil-tex-toggle-delim)

(after! evil-tex
  ;; `ts` starts Toggle Surround
  (setq evil-tex-toggle-override-t t))
#+END_SRC
** XeTeX

Add Xetex support (not working..)

#+BEGIN_SRC emacs-lisp
;; (after! latex
;;     (add-to-list TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t)))
#+END_SRC


* bibtex completion

** config

~bibtex-completion~ configuration through the package itself (should work in vanilla emacs).

#+BEGIN_SRC emacs-lisp
(map! :leader "b t" 'ivy-bibtex)
(map! :leader "b a" 'arxiv-lookup)

(after! bibtex-completion

  (setq! bibtex-completion-bibliography '("~/academia/bibliography/bibfile.bib")
         bibtex-completion-notes-path org-roam-directory
         bibtex-completion-library-path '("~/ucloud/my_stuff/papers" )))
#+END_SRC

You may store additional PDFs for a given entry, such as an annotated version of the original PDF, a file containing supplemental material, or chapter files.
All files whose name start with the BibTeX key will then be associated with an entry.
Note that for performance reasons, these additional files are only detected when triggering an action, such as “Open PDF file”. When the whole bibliography is loaded, only the “main” PDF bibtex-key.pdf is detected.

#+BEGIN_SRC emacs-lisp
(after! bibtex-completion
  (setq! bibtex-completion-find-additional-pdfs t))
#+END_SRC


Doom provides a way to configure ~bibtex-completion~ and ~org-ref~ at the same time through:

#+BEGIN_SRC emacs-lisp
(setq! +biblio-pdf-library-dir "~/ucloud/my_stuff/papers"
       +biblio-default-bibliography-files '("~/academia/bibliography/bibfile.bib")
       +biblio-notes-path org-roam-directory)
#+END_SRC

Use additional tags to find papers.

#+BEGIN_SRC emacs-lisp
(after! bibtex-completion
  (setq bibtex-completion-additional-search-fields '(tags)))
#+END_SRC

** ivy-bibtex

how to set ivy-height as a function [[https://github.com/abo-abo/swiper/issues/1722][github issue.]]

#+BEGIN_SRC emacs-lisp
(after! ivy-bibtex

  (setq ivy-height 30) ;; this is actually a general ivy configuration

  (defun bibtex-completion-pdf-open-with-zathura (entry)
    (let ((pdf (bibtex-completion-find-pdf entry)))
      (call-process "zathura" nil 0 nil (car pdf)))
      (kill-buffer "*doom*"))

  (defun bibtex-completion-pdf-open-with-evince (entry)
    (let ((pdf (bibtex-completion-find-pdf entry)))
      (call-process "evince" nil 0 nil (car pdf)))
      (+workspace/close-window-or-workspace)
      ;; (kill-buffer "*doom*")
      )

  ;; (ivy-add-actions 'ivy-bibtex '(("o" ivy-bibtex-open-any "Open PDF, URL, or DOI")))

  ;; (setq ivy-bibtex-default-action 'ivy-bibtex-insert-key)

;; the default action list is too long and there is no (obvious) way to remove entries so I start from scratch
(ivy-set-actions
 'ivy-bibtex
 '(("o" ivy-bibtex-open-any "Open PDF, URL, or DOI")
   ("i" ivy-bibtex-insert-key "Insert key")
   ;; ("a" ivy-bibtex-add-PDF-attachment "Attach PDF to email") ;; email not yet working
   ("s" ivy-bibtex-show-entry "Show entry")
   ("z" bibtex-completion-pdf-open-with-zathura "Open PDF in zathura")
   ("E" bibtex-completion-pdf-open-with-evince "Open PDF in Evince")
   ;; ("c" ivy-bibtex-insert-link-to-file "Insert link to file") ;; this could make org-ref obsolete
   ("e" ivy-bibtex-edit-notes "Edit notes"))))
#+END_SRC

** helm-bibtex

TODO: add "open in zathura"
#+BEGIN_SRC emacs-lisp
;; (helm-add-action-to-source "Open PDF with zathura" 'bibtex-completion-pdf-open-with-zathura helm-source-bibtex 1)
#+END_SRC

** org-ref

Conveniently insert citations in org files. These citations can be used to open the corresponding pdf or notes.
It would probably be more sensible to simply define a (helm/ivy)-bibtex command that inserts the link to the pdf instead if including a new package but ok..

#+BEGIN_SRC emacs-lisp
(after! org-ref
  (map! :localleader "i" nil)
  (map! :map org-mode-map
        :localleader
        :desc "insert citation" "i" #'org-ref-cite-insert-helm))
(after! org
  (map! :localleader "i" nil)
  (map! :map org-mode-map
        :localleader
        :desc "insert citation" "i" #'org-ref-cite-insert-helm))

(setq reftex-default-bibliography '("~/academia/bibliography/bibfile.bib"))
#+END_SRC

This opens a full screen helm buffer. Partial screen would be nicer! Is there an ivy option for this?

* snippets

Snippets are everything!

~yas-keymap~: "The active keymap while a snippet expansion is in progress."

#+BEGIN_SRC emacs-lisp
(after! yasnippet
  (setq yas-snippet-dirs '("~/.doom.d/snippets")
        yas-triggers-in-field t)
  ;; remove random additional newline at the end of new snippets
  (setq-default mode-require-final-newline nil)
  (map! :map yas-minor-mode-map
        :i "C-e" 'yas-expand
        :i "C-f" 'yas-next-field) ;; sometimes I don't want to expand and just go to the next field
  (map! :map yas-keymap "C-e" 'yas-next-field-or-maybe-expand))
#+END_SRC

For some reason ~yas-new-snippet~ cannot guess where to put the snippet (can't guess the mode).
Therefore I'm using ~yas/new-snippet~, although it's obsolete since yasnippet 0.8.
Note that Doom overwrites ~yas-new-snippet~ with ~+snippet/new~. Maybe this is where the problem happens.

#+BEGIN_SRC emacs-lisp
(after! yasnippet
  (map! :leader "s n" 'yas/new-snippet              ;; Snippet New
        ;; :leader "s f" '+snippet/find                ;; Snippet Go
        :leader "s g" 'yas-visit-snippet-file))      ;; Snippet Go
#+END_SRC


** auto expanding

For selected snippets I want them to be automatically expanded (without pressing a trigger key), similarly to what ~abbrev~ already offers (or ~iabbrev~ in vim). However, ~abbrev~ has a super weird syntax.

This code adds this functionality by adding ~#condition: 'auto~ to the header of the snippet.
Code is taken from [[https://github.com/joaotavora/yasnippet/issues/998][a github issue]].

#+BEGIN_SRC emacs-lisp
(defun ab/yas-try-expanding-auto-snippets ()
  (let ((yas-buffer-local-condition ''(require-snippet-condition . auto)))
    (yas-expand)))
(add-hook 'post-command-hook #'ab/yas-try-expanding-auto-snippets)
#+END_SRC
** allow snippets to modify buffer
I added some snippets which modify the buffer by deleting spaces before the snippet. This causes yasnippet to issue warnings.
Remove those warnings:
#+BEGIN_SRC emacs-lisp
(after! warnings
  (add-to-list 'warning-suppress-types '(yasnippet backquote-change)))
#+END_SRC

* syntax checking

#+BEGIN_SRC emacs-lisp
(after! flycheck
;;(flycheck-display-errors-delay .3)
;;(setq-default flycheck-disabled-checkers '(tex-chktex)))
  (map! :leader "a" 'flycheck-next-error))
#+END_SRC

There is a bug in ~chk-tex~, see [[https://github.com/flycheck/flycheck/issues/1214][issue]]. They also describe possible workarounds.

Fixing would be nice too, but apparently this is open, cf. [[https://github.com/flycheck/flycheck/issues/530][issue]].

* python
** config
#+BEGIN_SRC emacs-lisp
(after! python
  (map! :map python-mode-map
        :localleader "r r" 'run-python
                     "s s" 'python-shell-switch-to-shell
                     "s r" 'python-shell-send-region
                     "r s" 'pyvenv-restart-python
                     ","   'python-shell-send-buffer     ; replace C-c C-c
                     "c a" 'conda-env-activate
        ))
#+END_SRC

When making changes in other buffers (not the one I'm sending) they are not registered. So I keep having to restart the python process. So I decided to put this in the run function

#+BEGIN_SRC emacs-lisp
(defun python-shell-start-and-send-buffer()
  (interactive)
  (run-python)
  (evil-window-left)
  (python-shell-send-buffer))

(defun ab/restart-and-run-python()
  "restart and run to make sure all changes are registered when running code"

  (interactive)
  ;; (pyvenv-restart-python)
  (kill-process "Python")
  (sleep-for 0.05)
  (kill-buffer "*Python*")
  (previous-window-any-frame)
  (run-python))
#+END_SRC


** fixes
Supposed to fix the
~Warning (python): Your ‘python-shell-interpreter’ doesn’t seem to support readline, yet ‘python-shell-completion-native-enable’ was t and "python3" is not part of the ‘python-shell-completion-native-disabled-interpreters’ list.  Native completions have been disabled locally.~
Warning.
#+BEGIN_SRC emacs-lisp
(after! python
  (setq python-shell-completion-native-enable nil))
#+END_SRC
** conda

I automatically want the right conda environment activated when editing a python file.
How does emacs know which one is the right environment? I don't know..
#+BEGIN_SRC emacs-lisp
(after! conda
  (conda-env-initialize-eshell)
  (conda-env-autoactivate-mode))
#+END_SRC
** linting

Flycheck supports multiple checkers at once put only in a sequential fashion, see [[https://www.flycheck.org/en/latest/user/syntax-checkers.html#flycheck-checker-chains][flyckeck.org]]

This is the correct solution for doom emacs according to [[https://github.com/hlissner/doom-emacs/issues/1530][github]].


#+BEGIN_SRC emacs-lisp
;; (defun my-flycheck-setup ()
;;   (flycheck-add-next-checker 'lsp 'python-flake8))

;; ;; These MODE-local-vars-hook hooks are a Doom thing. They're executed after
;; ;; MODE-hook, on hack-local-variables-hook. Although `lsp!` is attached to
;; ;; python-mode-local-vars-hook, it should occur earlier than my-flycheck-setup
;; ;; this way:
;; (add-hook 'python-mode-local-vars-hook #'my-flycheck-setup)
#+END_SRC

A general emacs solution was suggested on [[https://www.reddit.com/r/emacs/comments/gqymvz/how_to_force_flycheck_to_select_a_specific_syntax/][reddit]] but doesn't work for doom.
** unicode
As julia, python allows for unicode characters but somehow entering them it is
not as easy as in julia (where it is sufficient to time the texcode and "TAB").

#+BEGIN_SRC emacs-lisp
(setq default-input-method "TeX")
#+END_SRC

* julia


shift-enter would also be nice for send line

#+BEGIN_SRC emacs-lisp
(map! :map julia-mode-map
    :localleader "r r"  'julia-repl
                 ","    'julia-repl-send-buffer
                 "l"    'julia-repl-send-line
                 "r l"  'julia-repl-send-line
    )
#+END_SRC

use nice terminal instead of the default ansi
#+BEGIN_SRC emacs-lisp
(after! julia-repl
  (julia-repl-set-terminal-backend 'vterm))
#+END_SRC

Define a minor mode to enable sending to julia-repl (taken from [[https://www.tquelch.com/posts/emacs-config/][here]]).
#+BEGIN_SRC emacs-lisp
(define-minor-mode julia-repl-interaction-mode
  "Toggle keybinds to send lines to the julia-repl"
  :keymap (let ((map (make-sparse-keymap)))
          (define-key map (kbd "C-s") #'julia-repl-send-region-or-line)
          map))
#+END_SRC


This fix is necessary for lsp to work in julia:
#+BEGIN_SRC emacs-lisp
(after! julia-mode
  (add-hook 'julia-mode-hook #'rainbow-delimiters-mode-enable)
  (add-hook! 'julia-mode-hook
    (setq-local lsp-enable-folding t
                lsp-folding-range-limit 100)))
#+END_SRC


* auto completion
** company

I used to think =company= is slow, but I just had to turn the ~idle-delay~ down...

#+BEGIN_SRC emacs-lisp
(after! company
  :init
  (setq company-dabbrev-ignore-case nil
        company-idle-delay 0.2
        ;; Number the candidates (use M-1, M-2 etc to select completions).
        company-show-quick-access t
        company-tooltip-limit 7
        company-tooltip-minimum-width 40
        company-minimum-prefix-length 2)
  (add-hook 'after-init-hook 'global-company-mode)
  :config
  ;; Add yasnippet support for all company backends
  ;; https://github.com/syl20bnr/spacemacs/pull/179
  (defvar company-mode/enable-yas t
    "Enable yasnippet for all backends.")
  (defun company-mode/backend-with-yas (backend)
    (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))
  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

  (map! :i "C-n" 'company-complete)) ;; doesn't work

(map! (:when (featurep! :completion company)
        :i "C-n"      #'+company/complete
        :i "C-SPC"    #'+company/complete))
#+END_SRC

The code chunk in the middle which makes yasnippet work with company is taken from [[https://emacs.stackexchange.com/questions/10431/get-company-to-show-suggestions-for-yasnippet-names][stackexchange]]. How can people live without this?? Also for some reason it has to be inside the entire thing even if company is not defered (no idea why).

** company-backends

For some reason it is super hard to get ~company-backends~ right...
This is copied from [[https://www.gtrun.org/post/init/#org-mode][here]].

#+BEGIN_SRC emacs-lisp
;; (set-company-backend! '(c-mode
;;                         ess-mode
;;                         emacs-lisp-mode
;;                         elisp-mode
;;                         latex-mode
;;                         tex-mode
;;                         lisp-mode
;;                         sh-mode
;;                         python-mode
;;                         )
;;   '(:separate  company-tabnine
;;                company-files
;;                company-capf
;;                company-yasnippet))

;; (setq +lsp-company-backend '(company-lsp :with company-tabnine :separate))
#+END_SRC
** lsp

#+BEGIN_SRC emacs-lisp
(after! lsp
  (setq lsp-ui-mode t))
#+END_SRC

* spell checking

As the name suggests. According to [[https://fasciism.com/2017/01/16/spellchecking/][this site]] Aspell is unmaintained and Hunspell is the way to go.

Default binding: ~z =~ for suggestions on how to correct the word.

#+BEGIN_SRC emacs-lisp
(after! flyspell
  :config
  (map! :leader "s c" 'flyspell-mode)      ;; toggle spell checking
  (map! :n "z=" 'ispell-word)

  (setq ispell-program-name "hunspell"
        ispell-silently-savep t            ;; save persal dictionary without asking
        ;; ispell-hunspell-dict-paths-alist '(("en_US" "~/.hunspell_en_US")
        ;;                                    ("de_AT" "~/.hunspell_de_AT"))
        ;; ispell-extra-args '("--sug-mode=ultra" "--lang=en_US")
        ;; ispell-list-command "--list"
        )
  (add-to-list 'ispell-local-dictionary-alist '(("en_US")))
  (add-to-list 'ispell-local-dictionary-alist '(("de_AT")))

  (add-to-list 'ispell-local-dictionary-alist '(("english-hunspell"
                                                 "[[:alpha:]]"
                                                 "[^[:alpha:]]"
                                                 "['‘’]"
                                                 t ; Many other characters
                                                 ("-d" "en_US")
                                                 nil
                                                 utf-8)))
  (add-to-list 'ispell-local-dictionary-alist '("deutsch-hunspell"
                                                "[[:alpha:]]"
                                                "[^[:alpha:]]"
                                                "[']"
                                                t
                                                ("-d" "de_AT"); Dictionary file name
                                                nil
                                                iso-8859-1))

)

#+END_SRC

Here some links on how to set hunspell, etc. up [[https://unix.stackexchange.com/questions/86554/make-hunspell-work-with-emacs-and-german-language][hunspell for two languages]], [[https://www.emacswiki.org/emacs/InteractiveSpell][emacswiki]], [[http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html][blog]].

vim has a command for directly adding new words to dictionary. I want this.

#+BEGIN_SRC emacs-lisp
(defun ab/save-word ()
  (interactive)
  (let ((current-location (point))
        (word (flyspell-get-word)))
    (when (consp word)
      (flyspell-do-correct 'save nil (car word) current-location (cadr word) (caddr word) current-location))))

(map! :n "z g" 'ab/save-word)
#+END_SRC

* fuzzy matching

The ~counsel~ package installs all three of them. ~Swiper~ is just the fancy
search. ~Ivy~ does the narrowing. ~counsel~ adds options to ~Ivy~

#+BEGIN_SRC emacs-lisp
(after! ivy
  (map! "C-s" 'counsel-grep-or-swiper)
  ;; Virtual buffers correspond to bookmarks and recent files list
  (setq ivy-use-virtual-buffers t))
#+END_SRC

* auto closing of parenthesis

Smart treatment of parenthesis, like auto closing or auto deletion of the matching one.

#+BEGIN_SRC emacs-lisp
(after! smartparens
  (sp-local-pair 'org-mode "$" "$")
  ;; (sp-local-pair 'latex-mode "$" "$")   ;; omg, I want this so badly
  (sp-local-pair 'latex-mode "\\langle" "\\rangle" :trigger "\\lan")
  (sp-local-pair 'latex-mode "\\lVert" "\\rVert" :trigger "\\lVe")

  (sp-local-pair 'latex-mode "\\left(" "\\right)" :trigger "\\(")
  (sp-local-pair 'latex-mode "\\left[" "\\right]" :trigger "\\l[")
  (sp-local-pair 'latex-mode "\\left\\{" "\\right\\}" :trigger "\\l{")
  (sp-local-pair 'latex-mode "\\left\\langle" "\\right\\rangle" :trigger "\\left\\la")

  (smartparens-global-mode 1)) ;; I always want this
#+END_SRC

* mail

** mu4e config

#+BEGIN_SRC emacs-lisp
(after! mu4e
  (setq +mu4e-backend 'offlineimap)
  (setq mu4e-root-maildir "~/.mail"))
#+END_SRC

Convenience function for starting the whole mu4e in its own frame.
Posted by the author of mu4e on the mailing list.

#+BEGIN_SRC emacs-lisp
(defun mu4e-in-new-frame ()
  "Start mu4e in new frame."
  (interactive)
  (select-frame (make-frame))
  (mu4e))
#+END_SRC
** univie mailbox

#+BEGIN_SRC emacs-lisp
(after! mu4e
  ;; Each path is relative to `+mu4e-mu4e-mail-path', which is ~/.mail by default
  (set-email-account! "uniwien"
                      '((user-full-name         . "Axel Böhm")
                        (user-mail-address      . "axel.boehm@univie.ac.at")
                        (smtpmail-smtp-user     . "boehma53")

                        (mu4e-sent-folder       . "/uniwien/INBOX.Sent/")
                        (mu4e-drafts-folder     . "/uniwien/INBOX.Drafts")
                        (mu4e-trash-folder      . "/uniwien/INBOX.Trash")
                        (mu4e-refile-folder     . "/uniwien/INBOX.Archive")
                        (smtpmail-smtp-server   . "mail.unvie.ac.at")
                        (smtpmail-default-smtp-server . "smtp.gmail.com")
                        (smtpmail-smtp-service  .  587)
                        (smtpmail-local-domain  . "univie.ac.at")
                        (mu4e-compose-signature . "---\nAxel Boehm"))
                      t)

  ;; use mu4e for e-mail in emacs
  (setq mail-user-agent 'mu4e-user-agent)
  ;; (Setq mu4e-sent-messages-behavior 'delete)

  ;; allow for updating mail using 'U' in the main view:
  ;; (setq mu4e-get-mail-command "offlineimap") )
  )
#+END_SRC

** ymail.

#+BEGIN_SRC emacs-lisp
(after! mu4e
  (set-email-account! "ymail"
    `((mu4e-sent-folder       . "/ymail/Sent")
      (mu4e-drafts-folder     . "/ymail/Drafts")
      (mu4e-trash-folder      . "/ymail/Trash")
      (mu4e-refile-folder     . "/ymail/Archive")
      ;; (smtpmail-smtp-user     . ,(auth-source-pass-get "user" "mail/mainmail"))
      ;; (user-mail-address      . ,(auth-source-pass-get "user" "mail/mainmail"))
      (mu4e-compose-signature . "---\nAxel Boehm"))))
#+END_SRC


still to do

** contacts

#+BEGIN_SRC emacs-lisp
;; ( org-contacts
;;   :after org
;;   :custom (org-contacts-files '("~/documents/contacts.org")))

;; (setq mu4e-org-contacts-file (car org-contacts-files))
;; (add-to-list 'mu4e-headers-actions
;;              '("org-contact-add" . mu4e-action-add-org-contact) t)
;; (add-to-list 'mu4e-view-actions
;;              '("org-contact-add" . mu4e-action-add-org-contact) t)
#+END_SRC

* dired

I'm so used to my ranger keybindings. Imitate those:

#+BEGIN_SRC emacs-lisp
(map! :map dired-mode
      "h" 'dired-up-directory)
#+END_SRC

* pdf

** Navigation

Navigate pdfs the way I'm used to.

#+BEGIN_SRC emacs-lisp
(after! pdf-tools

  ;; more fine-grained zooming
  (setq! pdf-view-resize-factor 1.1)

  ;; (map! image-mode-map
  ;;  :m "i"   'image-forward-hscroll)

  (map!
   :map pdf-view-mode-map
   :m "n"   'evil-collection-pdf-view-next-line-or-next-page
   :m "e"   'evil-collection-pdf-view-previous-line-or-previous-page
   :m "i"   'image-forward-hscroll
   ;; :m "gg"  'pdf-view-first-page
   ;; :m "G"   'pdf-view-last-page
   ;; :m "h"   'pdf-view-con
   :m "C-o" 'pdf-view-shrink
   :m "C-i" 'pdf-view-enlarge
   :m "C-u" 'pdf-view-scroll-down-or-previous-page
   :m "C-d" 'pdf-view-scroll-up-or-next-page))

#+END_SRC

** UI

Start in dark mode.

#+BEGIN_SRC emacs-lisp
(after! pdf-tools
  (add-hook! 'pdf-tools-enabled-hook 'pdf-view-midnight-minor-mode))
#+END_SRC

automatically annotate highlights.

#+BEGIN_SRC emacs-lisp
(setq pdf-annot-activate-created-annotations t)

(after! pdf-tools
  (map! :map pdf-view-mode-map
    :m "h" 'pdf-annot-add-highlight-markup-annotation)

  ;; automatically annotate highlights
  ;; (setq pdf-annot-activate-created-annotations t)
  )
#+END_SRC
* rss

#+BEGIN_SRC emacs-lisp
(map! :leader "e f" #'elfeed)
#+END_SRC

** set feeds

#+BEGIN_SRC emacs-lisp
(setq! elfeed-feeds
      '(("http://export.arxiv.org/api/query?search_query=cat:math.OC&start=0&max_results=300&sortBy=submittedDate&sortOrder=descending" research)
        ("http://www.argmin.net/feed.xml" blog)))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(after! elfeed
  (setq elfeed-search-filter "@1-month-ago"))
#+END_SRC



rename the feeds
#+BEGIN_SRC emacs-lisp
(defadvice elfeed-search-update (before nullprogram activate)
  (let ((feed (elfeed-db-get-feed "http://export.arxiv.org/api/query?search_query=cat:math.OC&start=0&max_results=300&sortBy=submittedDate&sortOrder=descending")))
    (setf (elfeed-feed-title feed) "arXiv optimization")))
#+END_SRC

** keybindings

By default q only closes the buffer but leaves the window open....
#+BEGIN_SRC emacs-lisp
;; (map! :map elfeed-show-mode-map
;;       :n "q" #'elfeed-search-quit-window)

(after! elfeed
  (map! :map elfeed-show-mode-map
        :n "q" #'elfeed-search-quit-window))
#+END_SRC


not yet working
#+BEGIN_SRC emacs-lisp

(after! elfeed
  (map! :map elfeed-search-mode-map
        :n "i" #'elfeed-search-show-entry))

(map! :map elfeed-show-mode-map
      :after elfeed-show
      :n "h" #'elfeed-search-quit-window
      :n "N" #'elfeed-show-next
      :n "E" #'elfeed-show-prev
      :n "y" #'elfeed-show-yank)

#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (defun elfeed-search-show-entry-pre (&optional lines)
;;   "Returns a function to scroll forward or back in the Elfeed
;;   search results, displaying entries without switching to them."
;;       (lambda (times)
;;         (interactive "p")
;;         (forward-line (* times (or lines 0)))
;;         (recenter)
;;         (call-interactively #'elfeed-search-show-entry)
;;         (select-window (previous-window))
;;         (unless elfeed-search-remain-on-entry (forward-line -1))))

;; (after! elfeed
;;   (define-key elfeed-search-mode-map (kbd "N") (elfeed-search-show-entry-pre +1))
;;   (define-key elfeed-search-mode-map (kbd "E") (elfeed-search-show-entry-pre -1)))
#+END_SRC

** attempt

# #+BEGIN_SRC emacs-lisp
# (defvar elfeed-show-mode-map
#   (let ((map (make-sparse-keymap)))
#     (prog1 map
#       (suppress-keymap map)
#       (define-key map "d" 'elfeed-show-save-enclosure)
#       (define-key map "q" 'elfeed-kill-buffer)
#       (define-key map "g" 'elfeed-show-refresh)
#       (define-key map "n" 'elfeed-show-next)
#       (define-key map "N" 'elfeed-show-next)
#       (define-key map "p" 'elfeed-show-prev)
#       (define-key map "s" 'elfeed-show-new-live-search)
#       (define-key map "b" 'elfeed-show-visit)
#       (define-key map "y" 'elfeed-show-yank)
#       (define-key map "A" 'elfeed-show-add-enclosure-to-playlist)
#       (define-key map "P" 'elfeed-show-play-enclosure)))
#   "Keymap for `elfeed-show-mode'.")
# #+END_SRC
** tecosaur

#+BEGIN_SRC emacs-lisp
;; (map! :map elfeed-search-mode-map
;;       :after elfeed-search
;;       [remap kill-this-buffer] "q"
;;       [remap kill-buffer] "q"
;;       :n doom-leader-key nil
;;       :n "q" #'+rss/quit
;;       :n "e" #'elfeed-update
;;       :n "r" #'elfeed-search-untag-all-unread
;;       :n "u" #'elfeed-search-tag-all-unread
;;       :n "s" #'elfeed-search-live-filter
;;       :n "RET" #'elfeed-search-show-entry
;;       :n "p" #'elfeed-show-pdf
;;       :n "+" #'elfeed-search-tag-all
;;       :n "-" #'elfeed-search-untag-all
;;       :n "S" #'elfeed-search-set-filter
;;       :n "b" #'elfeed-search-browse-url
;;       :n "y" #'elfeed-search-yank)
;; (after! evil

;; (map! :map elfeed-show-mode-map
;;       :after elfeed-show
;;       [remap kill-this-buffer] "q"
;;       [remap kill-buffer] "q"
;;       :n doom-leader-key nil
;;       :nm "q" #'+rss/delete-pane
;;       :nm "o" #'ace-link-elfeed
;;       :nm "RET" #'org-ref-elfeed-add
;;       :nm "N" #'elfeed-show-next
;;       :nm "E" #'elfeed-show-prev
;;       :nm "p" #'elfeed-show-pdf
;;       :nm "+" #'elfeed-show-tag
;;       :nm "-" #'elfeed-show-untag
;;       :nm "s" #'elfeed-show-new-live-search
;;       :nm "y" #'elfeed-show-yank))

;; (after! elfeed-search
;;   (set-evil-initial-state! 'elfeed-search-mode 'normal))
;; (after! elfeed-show-mode
;;   (set-evil-initial-state! 'elfeed-show-mode   'normal))

;; (after! evil-snipe
;;   (push 'elfeed-show-mode   evil-snipe-disabled-modes)
;;   (push 'elfeed-search-mode evil-snipe-disabled-modes))
#+END_SRC


** misc

load new feeds when opened
#+BEGIN_SRC emacs-lisp
(add-hook! 'elfeed-search-mode-hook 'elfeed-update)
#+END_SRC

A helper function that gets the authors names.
#+BEGIN_SRC emacs-lisp
(defun concatenate-authors (authors-list)
  "Given AUTHORS-LIST, list of plists; return string of all authors concatenated."
  (if (> (length authors-list) 1)
      (format "%s et al." (plist-get (nth 0 authors-list) :name))
    (plist-get (nth 0 authors-list) :name)))
#+END_SRC

date and width
#+BEGIN_SRC emacs-lisp
;; (setq! elfeed-search-date-format '("%y-%m-%d" 10 :left))
;; (setq! elfeed-search-title-max-width 110)
#+END_SRC

Customize how the opened entries look (show things like title, author,...)
#+BEGIN_SRC emacs-lisp
(defun my-search-print-fn (entry)
  "Print ENTRY to the buffer."
  (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
         (title (or (elfeed-meta entry :title)
                    (elfeed-entry-title entry) ""))
         (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
         (entry-authors (concatenate-authors
                         (elfeed-meta entry :authors)))
         (title-width (- (window-width) 10
                         elfeed-search-trailing-width))
         (title-column (elfeed-format-column
                        title 100
                        :left))
         ;; (entry-score (elfeed-format-column (number-to-string (elfeed-score-scoring-get-score-from-entry entry)) 10 :left))
         (authors-column (elfeed-format-column entry-authors 40 :left)))
    (insert (propertize date 'face 'elfeed-search-date-face) " ")

    (insert (propertize title-column
                        'face title-faces 'kbd-help title) " ")
    (insert (propertize authors-column
                        'kbd-help entry-authors) " ")
    ;; (insert entry-score " ")
    ))

(setq! elfeed-search-print-entry-function #'my-search-print-fn)
;; (after! elfeed
;;   (setq! elfeed-search-print-entry-function #'my-search-print-fn))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; (defun robo/elfeed-entry-to-arxiv ()
;;   "Fetch an arXiv paper into the local library from the current elfeed entry."
;;   (interactive)
;;   (let* ((link (elfeed-entry-link elfeed-show-entry))
;;          (match-idx (string-match "arxiv.org/abs/\\([0-9.]*\\)" link))
;;          (matched-arxiv-number (match-string 1 link)))
;;     (when matched-arxiv-number
;;       (message "Going to arXiv: %s" matched-arxiv-number)
;;       (arxiv-get-pdf-add-bibtex-entry matched-arxiv-number +biblio-default-bibliography-files +biblio-pdf-library-dir))))

;; (map! (:after elfeed
;;        (:map elfeed-search-mode-map
;;         :desc "Open entry" "m" #'elfeed-search-show-entry)
;;        (:map elfeed-show-mode-map
;;         :desc "Fetch arXiv paper to the local library" "a" #'robo/elfeed-entry-to-arxiv)))
#+END_SRC

*** a similiar config from a different website

from [[https://cundy.me/post/elfeed/][here:]]

#+BEGIN_SRC emacs-lisp
;; (defun ab/concatenate-authors (authors-list)
;;   "Given AUTHORS-LIST, list of plists; return string of all authors concatenated."
;;   (mapconcat
;;    (lambda (author) (plist-get author :name))
;;    authors-list ", "))
#+END_SRC


#+BEGIN_SRC emacs-lisp
;; (defun my-search-print-fn (entry)
;;   "Print ENTRY to the buffer."
;;   (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
;; 	 (title (or (elfeed-meta entry :title)
;; 		    (elfeed-entry-title entry) ""))
;; 	 (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
;; 	 (feed (elfeed-entry-feed entry))
;; 	 (feed-title
;; 	  (when feed
;; 	    (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
;; 	 (entry-authors (ab/concatenate-authors
;; 			 (elfeed-meta entry :authors)))
;; 	 (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
;; 	 (tags-str (mapconcat
;; 		    (lambda (s) (propertize s 'face
;; 					    'elfeed-search-tag-face))
;; 		    tags ","))
;; 	 (title-width (- (window-width) 10
;; 			 elfeed-search-trailing-width))
;; 	 (title-column (elfeed-format-column
;; 			title (elfeed-clamp
;; 			       elfeed-search-title-min-width
;; 			       title-width
;; 			       elfeed-search-title-max-width)
;; 			:left))
;; 	 (authors-width 135)
;; 	 (authors-column (elfeed-format-column
;; 			entry-authors (elfeed-clamp
;; 			       elfeed-search-title-min-width
;; 			       authors-width
;; 			       131)
;; 			:left)))

;;     (insert (propertize date 'face 'elfeed-search-date-face) " ")

;;     (insert (propertize title-column
;; 			'face title-faces 'kbd-help title) " ")

;;     (insert (propertize authors-column
;; 			'face 'elfeed-search-date-face
;; 			'kbd-help entry-authors) " ")

;;     ;; (when feed-title
;;     ;;   (insert (propertize entry-authors
;;     ;; 'face 'elfeed-search-feed-face) " "))

;;     (when entry-authors
;;       (insert (propertize feed-title
;; 			  'face 'elfeed-search-feed-face) " "))

;;     ;; (when tags
;;     ;;   (insert "(" tags-str ")"))

;;     )
;;   )
;; (setq elfeed-search-print-entry-function #'my-search-print-fn)
#+END_SRC

** scoring
scoring based on keywords
#+BEGIN_SRC emacs-lisp
;; (elfeed-score-load-score-file "~/.doom.d/elfeed.score") ; See the elfeed-score documentation for the score file syntax
;; (setq! elfeed-score-serde-score-file "~/.doom.d/elfeed.serde.score")
;; (elfeed-score-enable)
;; (define-key elfeed-search-mode-map "=" elfeed-score-map)
#+END_SRC




* ~avy~

** keys being used :colemak:

~avy~ uses the qwerty home row by default. Change this.

#+BEGIN_SRC emacs-lisp
(setq avy-keys '(?a ?r ?s ?t ?d ?h ?n ?e ?i ?o))
#+END_SRC


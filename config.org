#+TITLE: config

* general config
** localleader

#+BEGIN_SRC emacs-lisp
(setq doom-localleader-key ",")
#+END_SRC

** ui
*** theme

#+BEGIN_SRC emacs-lisp
(setq doom-theme 'doom-nord)
#+END_SRC

*** curser theme

#+BEGIN_SRC emacs-lisp
(set-cursor-color "#ffb6c1")
#+END_SRC
*** font

#+BEGIN_SRC emacs-lisp
(setq doom-font (font-spec :family "xos4 Terminus" :size 13))
#+END_SRC

*** paren-mode
Highlight matching parentheses and such in every mode.

#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)
#+END_SRC

*** line number

Show line numbers to the left for better jumping.
(consider the ace jump package which shows a letter for every line for more efficient jumping)

#+BEGIN_SRC emacs-lisp
;; (setq display-line-numbers-type 'relative)
(setq display-line-numbers-type nil)
#+END_SRC

*** line truncation

stupid doom tries to truncate lines all the time which I don't like. This means that long lines go past the window end. When this is turned off they appear soft wrapped.

#+BEGIN_SRC emacs-lisp
(setq-default truncate-lines nil)
#+END_SRC

I have still no idea how this relates to ~visual-line-mode~. Seems to do the same...

*** pretty symbols

Emacs ships default with =prettify-symbols mode=.

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode 1)
#+END_SRC
doesn't seem to do anything in doom

*** hl-line

Highlighting the current line is all nice and stuff but it looks off in org mode due to different sizes of headings.
Similarly in LaTeX due to sub/super -scripts.

#+BEGIN_SRC emacs-lisp
(remove-hook 'text-mode-hook #'hl-line-mode)
#+END_SRC

*** opacity

Make emacs opaque (when running compton).

#+BEGIN_SRC emacs-lisp
(set-frame-parameter (selected-frame) 'alpha '(85 . 85))
(add-to-list 'default-frame-alist '(alpha . (85 . 85)))
#+END_SRC
*** modeline

#+BEGIN_SRC emacs-lisp
(after! doom-modeline
  ;; Disable unwanted modeline details.
  (size-indication-mode 0)

  ;; ;; Define a new default modeline.
  ;; (doom-modeline-def-modeline 'myline
  ;;   '(bar workspace-name window-number buffer-info remote-host)
  ;;   '(matches debug checker))

  ;; ;; Actually use the new settings.
  ;; (add-hook 'doom-modeline-mode-hook
  ;;   (lambda ()
  ;;     (doom-modeline-set-modeline 'myline 'default)))
  )
#+END_SRC
*** hl-todo

highlight keywords like TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW.

#+BEGIN_SRC emacs-lisp
(global-hl-todo-mode)
#+END_SRC

** general behavior

When splitting windows, put split on a reasonable side.

#+BEGIN_SRC emacs-lisp
(setq evil-split-window-below t
      evil-vsplit-window-right t)
#+END_SRC

I don't want aut-fill on by DEFAULT

#+BEGIN_SRC emacs-lisp
(remove-hook 'text-mode-hook #'auto-fill-mode)
#+END_SRC

When moving up or down. Start moving the text before the curser hits the border of the screen. Equivalent to vims ~scroll-off~.

#+BEGIN_SRC emacs-lisp
(setq scroll-margin 5)
#+END_SRC

** email

currently still using mutt. This tells Emacs to use mail mode when editing emails through mutt.

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("/mutt" . mail-mode))
(add-to-list 'auto-mode-alist '("/neomutt" . mail-mode))
#+END_SRC

Turn on auto fill and break after specified number of chars

#+BEGIN_SRC emacs-lisp
(add-hook 'mail-mode-hook #'auto-fill-mode)
(add-hook 'mail-mode-hook
          (lambda ()
            (set-fill-column 72)))
#+END_SRC

This is copied from [[https://github.com/NicolasPetton/emacs.d/blob/3945786c31a17ac9caa8894109c231234956102f/hosts/blueberry/init-notmuch.el][github]] who took it from [[http://blog.binchen.org/posts/how-to-use-yasnippets-to-produce-email-templates-in-emacs.html][this blog]].

#+BEGIN_SRC emacs-lisp
;; Function to return first name of email recipient
;; Used by yasnippet
#+END_SRC

** dashboard

Show agenda for upcoming week and not just today.

#+BEGIN_SRC emacs-lisp
(setq show-week-agenda-p t)
#+END_SRC

** GTD

Keep everything out of your head, aka building a second brain.

#+BEGIN_SRC emacs-lisp
(defun ab/visit-references ()
  "go to my references file"
  (interactive)
  (find-file "~/org/Reference.org"))
#+END_SRC

** general nifty mappings

Most of the time I only have two windows open. Switching between should be easy.

#+BEGIN_SRC emacs-lisp
(map! "M-w" 'other-window)
#+END_SRC

~counsel-find-file~ lets you open a file in a new split, but with a weird mapping ~C-o j~.
I want a better one. However. this currently only works for ~find-file~ and not ~find-buffer~.


#+BEGIN_SRC emacs-lisp
(defun ivy-ffow-done ()
  "Exit the minibuffer, opening candidate in other window."
  (interactive)
  (ivy-set-action #'find-file-other-window)
  (ivy-done))

(map! :after counsel
      :map counsel-find-file-map
      "M-RET" #'ivy-ffow-done)
#+END_SRC

* config file

** quick access

Configuring never stops. keep the config file close.

#+BEGIN_SRC emacs-lisp
(defun ab/visit-emacs-config ()
  "go to emacs config file"
  (interactive)
  (find-file "~/.doom.d/config.org"))

(map! :leader "e c" #'ab/visit-emacs-config)
#+END_SRC

** reload
When regularly changing configs we also want to be able to use them without restarting emacs.

#+BEGIN_SRC emacs-lisp
(defun ab/reload-init-file ()
  "reload config file"
  (interactive)
  (load-file "~/.doom.d/config.el"))

(map! :leader "e r" 'ab/reload-init-file)
#+END_SRC

* vi
** config

Not quite sure what this does but it seems to fix some weird behavior with
visual lines

#+BEGIN_SRC emacs-lisp
(setq evil-respect-visual-line-mode nil)
#+END_SRC

If I don't set this, long lines are just cut off and the remainder is not displayed. Makes it impossible to edit such lines.

** leader

More vim functionality.

Set the leader key and some very basic keybindings.

#+BEGIN_SRC emacs-lisp
(map! :leader
      "q" #'kill-buffer
      "s h" #'evil-window-split
      "s v" #'evil-window-vsplit
      "e c" #'ab/visit-emacs-config
      "r" #'ab/visit-references
      "n" #'other-window
      "w" #'save-buffer)
#+END_SRC


Quickly open shell in a split.

#+BEGIN_SRC emacs-lisp
(defun ab/open-shell-in-split ()
  ;; open eshell
  (interactive)
  ;; (evil-window-split)
  (eshell))

(map! :leader "s s" 'ab/open-shell-in-split)
#+END_SRC
** colemak settings :colemak:

Evil for colemak keyboard layout. Adapted from the [[https://github.com/wbolster/evil-colemak-basics][evil-colemak-basics]] package. For some reason trying to defining everything manually via ~evil-define-key~ or ~define-key evil-motion-state-map~ gave me trouble with ~'inner-text-objects~ and more..

#+BEGIN_SRC emacs-lisp
(defgroup evil-colemak nil
  "Basic key rebindings for evil-mode with the Colemak keyboard layout."
  :prefix "evil-colemak-"
  :group 'evil)

(defcustom evil-colemak-char-jump-commands nil
  "The set of commands to use for jumping to characters.
        By default, the built-in evil commands evil-find-char (and
        variations) are used"
  :group 'evil-colemak
  :type '(choice (const :tag "default" nil)))

(defun evil-colemak--make-keymap ()
  "Initialise the keymap baset on the current configuration."
  (let ((keymap (make-sparse-keymap)))
    (evil-define-key '(motion normal visual) keymap
      "n" 'evil-next-line
      "gn" 'evil-next-visual-line
      "gN" 'evil-next-visual-line
      "e" 'evil-previous-line
      "ge" 'evil-previous-visual-line
      "E" 'evil-lookup
      "i" 'evil-forward-char
      "I" 'evil-end-of-line
      "j" 'evil-forward-word-end
      "J" 'evil-forward-WORD-end
      "gj" 'evil-backward-word-end
      "gJ" 'evil-backward-WORD-end
      "k" 'evil-ex-search-next       ;; doom needs an "ex"
      "K" 'evil-ex-search-previous   ;; doom needs an "ex"
      "gk" 'evil-next-match
      "gK" 'evil-previous-match
      "zi" 'evil-scroll-column-right
      "zI" 'evil-scroll-right)
    (evil-define-key '(normal visual) keymap
      "N" 'evil-join
      "gN" 'evil-join-whitespace)
    (evil-define-key 'normal keymap
      "l" 'evil-insert
      "L" 'evil-insert-line)
    (evil-define-key 'visual keymap
      "L" 'evil-insert)
    (evil-define-key '(visual operator) keymap
      "l" evil-inner-text-objects-map)
    (evil-define-key 'operator keymap
      "i" 'evil-forward-char)
    keymap))
;; ~I~ is still available

(defvar evil-colemak-keymap
  (evil-colemak--make-keymap)
  "Keymap for evil-colemak-mode.")

(defun evil-colemak-refresh-keymap ()
  "Refresh the keymap using the current configuration."
  (setq evil-colemak-keymap (evil-colemak--make-keymap)))

      ;;;###autoload
(define-minor-mode evil-colemak-mode
  "Minor mode with evil-mode enhancements for the Colemak keyboard layout."
  :keymap evil-colemak-keymap
  :lighter " hnei")

      ;;;###autoload
(define-globalized-minor-mode global-evil-colemak-mode
  evil-colemak-mode
  (lambda () (evil-colemak-mode t))
  "Global minor mode with evil-mode enhancements for the Colemak keyboard layout.")

(after! evil
  (global-evil-colemak-mode))

;; (map! "I" 'evil-org-end-of-line)
;; (map! "H" 'evil-first-non-blank)
#+END_SRC

Switching windows also relies on the `hjkl` motions. So make it colemak friendly.

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil-maps
  (define-key evil-window-map "n" 'evil-window-down)
  (define-key evil-window-map "e" 'evil-window-up)
  (define-key evil-window-map "i" 'evil-window-right))
#+END_SRC

** ~matchit~

Extend the ~%~ functionality to jump between tags such as LaTeX ~\begin{...}~ and ~\end{...}~. This is sooo important!!!

#+BEGIN_SRC emacs-lisp
(after! evil
  (use-package! evil-matchit
    :config
    (global-evil-matchit-mode)))
#+END_SRC

** paragraph

The function ~evil-forward-paragraph~ (default bound to ~}~) reuses Emacs'
~forward-paragraph~ which is different in every major mode. I've gotten used to
vim's behaviour of just going to the next empty line. This chunk makes evil use
the default paragraph. This makes so much more sense considering commands like
~y a p~ (read "yank around paragraph") treats paragraphs always the the way I
want them. Got this from [[https://emacs.stackexchange.com/questions/38596/make-evil-paragraphs-behave-like-vim-paragraphs][here]].

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'evil
  (defadvice forward-evil-paragraph (around default-values activate)
    (let ((paragraph-start (default-value 'paragraph-start))
          (paragraph-separate (default-value 'paragraph-separate)))
      ad-do-it)))
#+END_SRC
** custom :colemak:

Custom mappings.

#+BEGIN_SRC emacs-lisp
(after! evil
  (map! :mnv "H" #'evil-first-non-blank
        :mnv "I" #'evil-end-of-line
        :mnv "E" #'+lookup/definition
        :mnv "S" #'evil-avy-goto-char
        :leader "l" 'avy-goto-line)
  )
#+END_SRC

I need to figure out how to make ~avy~ use other letters than the querty home row..

~evil-org-mode~ overrides some of my colemak settings. Override them again afterwards.
#+BEGIN_SRC emacs-lisp
(after! evil-org
  (map! :map evil-org-mode-map
        :mnvo "i" #'evil-forward-char
        :mnvo "I" #'evil-org-end-of-line))
#+END_SRC

* buffer handling

Switch back and forth between the two MRU buffers.

#+BEGIN_SRC emacs-lisp
(defun ab/switch-to-previous-buffer ()
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))

(map! :leader "SPC" #'ab/switch-to-previous-buffer)
#+END_SRC

* org mode

#+begin_center
=Your life in plain text=
#+end_center

** config

Load orgmode plus some standard keybindings.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-hide-emphasis-markers nil
        org-return-follows-link t
        +org-initial-fold-level 1
        org-reverse-note-order t            ;; add new headings on top
        org-tags-column 0                   ;; position of tags
        org-todo-keywords '((sequence "TODO(t)"
                                      "WAITING(w)"
                                      "|"
                                      "DONE(d)")
                            ;; research specific
                            (sequence "TODO(t)"
                                      "DIDN'T SUCCEED(s)"
                                      "|"
                                      "DOESN'T WORK(x)"
                                      "TOO HARD(h)"
                                      "DONE(d)"))
        org-todo-keyword-faces '(("WAITING" :foreground "#8FBCBB" :weight bold))))

(map! :leader
      "o s l" 'org-store-link
      "o a" 'org-agenda
      "o c" 'org-capture)
#+END_SRC

Line numbers in org mode are useless.

#+BEGIN_SRC emacs-lisp
(defun ab/disable-line-numbers ()
  (interactive)
  (display-line-numbers-mode -1))

(add-hook 'org-mode-hook #'ab/disable-line-numbers)
#+END_SRC

** appearance

heading size and color.
#+BEGIN_SRC emacs-lisp
(after! org
  (custom-set-faces
   '(org-level-1 ((t (:inherit outline-1 :height 1.5))))
   '(org-level-2 ((t (:inherit outline-2 :height 1.3))))
   '(org-level-3 ((t (:inherit outline-3 :height 1.2))))
   '(org-level-4 ((t (:inherit outline-4 :height 1.0))))
   '(org-level-5 ((t (:inherit outline-5 :height 1.0))))
   ))
#+END_SRC

configure the symbol for stuff hidden after heading.
#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-ellipsis " ..."))
#+END_SRC

pretty stuff
#+BEGIN_SRC emacs-lisp
;; (after! org
;;   (setq org-pretty-entities 1))
#+END_SRC

** structure and files

Tell emacs where I store my org stuff.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-directory "~/org")

  (defun org-file-path (filename)
    "Return the absolute address of an org file, given its relative name."
    (concat (file-name-as-directory org-directory) filename))

  ;; (setq org-inbox-file "~/org/inbox.org")
  (setq org-index-file (org-file-path "index.org"))
  (setq org-inbox-file "~/Dropbox/GTD/inbox.org")
  (setq org-archive-location
        (concat (org-file-path "archive.org") "::* From %s")))
#+END_SRC

This sets the file from which the agenda is derived. All my todos are in the index file.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-agenda-files (list org-index-file
                               (org-file-path "Reference.org"))))
#+END_SRC

By default org-mode does super ugly truncation of long lines (apparently because of tables). I want line wrapping, however.

#+BEGIN_SRC emacs-lisp
(after! org (setq org-startup-truncated 'nil))
#+END_SRC

By default org-agenda only shows one week starting last monday. I want two weeks starting today.

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-agenda-span 14)
  (setq org-agenda-start-on-weekday nil)
  (setq org-agenda-start-day "-0d"))
#+END_SRC
** export

#+BEGIN_SRC emacs-lisp
;; (after! org
;;   (setq org-export-use-babel t)
;;   (map! :map org-mode-map
;;         :leader
;;         (:prefix "e"
;;           (:prefix ("p" . "latex")
;;             :desc "to latex"            "l" #'org-pandoc-export-to-latex
;;             :desc "to latex & open"     "L" #'org-pandoc-export-to-latex-and-open
;;             :desc "to latex pdf"        "p" #'org-pandoc-export-to-latex-pdf
;;             :desc "to latex pdf & open" "P" #'org-pandoc-export-to-latex-pdf-and-open))
;;         (:prefix ("o" . "src")
;;           :desc "previous block"        "p" #'org-babel-previous-src-block
;;           :desc "next block"            "n" #'org-babel-next-src-block
;;           :desc "execute block"         "e" #'org-babel-execute-src-block)))
#+END_SRC

** keybindings
*** structure editing

Org structure editing made easy/mnemonic.

#+BEGIN_SRC emacs-lisp
(after! org
  (map! :map org-mode-map
        :localleader
        "w" 'widen                   ;; show everythig
        "n" 'org-toggle-narrow-to-subtree)  ;; show only what's within heading
)
#+END_SRC

~org-narrow-subtree~ shows only a single heading (the heading of the current subtree). I need more context!! I want to see which hierarchy this heading belongs to. Taken from [[https://emacs.stackexchange.com/questions/29304/how-to-show-all-contents-of-current-subtree-and-fold-all-the-other-subtrees][stackexchange]].

#+BEGIN_SRC emacs-lisp
(defun ab/org-show-just-me (&rest _)
  "Fold all other trees, then show entire current subtree."
  (interactive)
  (org-overview)
  (org-reveal)
  (org-show-subtree))

(map! :map org-mode-map
      :localleader "N" 'ab/org-show-just-me)            ;; Mnemonic: narrow
#+END_SRC
What I don't like is that this also shows all heading of level 1 and all headings of the same level as current heading.

Use vim instead of arrows.
#+BEGIN_SRC emacs-lisp
(map! :map org-mode-map
      "M-e" #'org-metaup
      "M-i" #'org-metaright
      "M-n" #'org-metadown)
#+END_SRC

Use ~o~ instead of ~RET~ for new headings/list-items.
#+BEGIN_SRC emacs-lisp
(after! org
  (map! :map org-mode-map
        "M-o" '+org/insert-item-below
        "M-O" '+org/insert-item-above))
#+END_SRC

*** index file

#+BEGIN_SRC emacs-lisp
;; (defun ab/copy-tasks-from-mobile
;;   "Copy tasks I added from Orgzly"
;;   (interactive)
;;   (when (file-exists-p org-inbox-file)
;;     (save-excursion
;;       (find-file org-inbox-file)
;;       (org-refile org-index-file)))
;;     )
#+END_SRC


Quickly access the org index file.

#+BEGIN_SRC emacs-lisp
(defun ab/open-index-file ()
  "Open the master org TODO list."
  (interactive)
  (find-file org-inbox-file)
  (split-window-horizontally)
  (find-file org-index-file)
  )

(map! :leader "i" #'ab/open-index-file)
#+END_SRC

*** navigation

Mnemonic navigation.

#+BEGIN_SRC emacs-lisp
(map! :map org-mode-map
        :leader
        "g h" 'org-previous-visible-heading      ;; Go Heading of current section
        "g e" 'org-previous-visible-heading      ;; Go e (= colemak up)
        "g u" 'outline-up-heading                ;; Go Up in hierarchy
        "g n" 'org-next-visible-heading          ;; Go Next heading
        )
#+END_SRC

The above motions are easy to remember but feel clunky when trying to go more then one heading up or down (this is probably an antipattern anyways..). Either way, here are some single key mappings.
I don't use ~(~ or ~)~ in evil mode anyways.

#+BEGIN_SRC emacs-lisp
(map! :map org-mode-map
   :n ")" 'org-next-visible-heading
   :n "(" 'org-previous-visible-heading
   :leader "g u" 'outline-up-heading)               ;; Go Up in hierarchy
#+END_SRC

By default ~g u~ is bound to ~evil-downcase~.

*** archiving

When I archive something it is usually also done. By default however archiving doesn't change the todo-state.
So let's have a command that does both.

#+BEGIN_SRC emacs-lisp
(defun ab/mark-done-and-archive ()
  "Mark the state of an org-mode item as DONE and archive it."
  (interactive)
  (org-todo 'done)
  (org-archive-subtree))

(map! :map org-mode-map :leader "o d" 'ab/mark-done-and-archive)
#+END_SRC

** org capture

Keep everything out of your head! Has to be as convenient as possible.

*** config

Always start in insert mode when capturing.

#+BEGIN_SRC emacs-lisp
(after! org
  (add-hook 'org-capture-mode-hook 'evil-insert-state))
#+END_SRC

When refiling I want to be able to refile also to a sub(sub...)headings.
Default only allows for ~level 3~ or so.

#+BEGIN_SRC emacs-lisp
(after! org
 (setq org-refile-targets '((nil :maxlevel . 6)
                            (org-agenda-files :maxlevel . 6))))
;; (setq org-completion-use-ido t)

;; (setq org-outline-path-complete-in-steps nil) ;; has to be nil for ido to work
;; (setq org-refile-use-outline-path 'file)
#+END_SRC

This seems to work in doom out of the box.

*** templates

Templates for capturing. Also, ~%a~ expands to a link to the file (and position) from which =org-capture= was called. I think =%i= is active region. Another nice feature is ~%^{Name}~ prompts for name. This probably makes sense for titles or something because I tend to put too much next to the asterics and too little text underneath..

#+BEGIN_SRC emacs-lisp
(after! org
  (setq org-capture-templates
        '(("l" "todo with Link" entry
           (file+headline org-index-file "Inbox")
           "*** TODO %?\n  %i\n  See: %a\n")

          ("n" "Note"  entry
           (file+headline org-index-file "Inbox")
           "*** %?\n\n")


          ("t" "Todo" entry
           (file+headline org-index-file "Inbox")
           "*** TODO %?\n"))))
#+END_SRC

Scheduled task with notifier.

#+BEGIN_SRC emacs-lisp
(after! org (add-to-list 'org-capture-templates
          '("s" "Scheduled task"  entry
           (file+headline org-index-file "Inbox")
           "*** TODO %^{taskname}
SCHEDULED: %(org-insert-time-stamp (org-read-date nil t \"+0d\"))
:PROPERTIES:
:CREATED: %U
:WILD_NOTIFIER_NOTIFY_BEFORE: 30 5
:END:
%?
")))
#+END_SRC

*** capture anywhere

Call org-capture from anywhere (system wide). Code taken from [[https://www.reddit.com/r/emacs/comments/74gkeq/system_wide_org_capture/][reddit.]]

#+BEGIN_SRC emacs-lisp
(after! org
  (defadvice org-switch-to-buffer-other-window
      (after supress-window-splitting activate)
    "Delete the extra window if we're in a capture frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-other-windows)))

  (defadvice org-capture-finalize
      (after delete-capture-frame activate)
    "Advise capture-finalize to close the frame"
    (if (equal "capture" (frame-parameter nil 'name))
        (delete-frame)))

  (defun activate-capture-frame ()
    "run org-capture in capture frame"
    (select-frame-by-name "capture")
    (switch-to-buffer (get-buffer-create "*scratch*"))
    (org-capture)))
#+END_SRC

The above code, together with the follow shell command does the job.

# #+BEGIN_SRC shell :eval no
# emacsclient -c -F '(quote (name . "capture"))' -e '(activate-capture-frame)'
# #+END_SRC

For this to work the emacs server hast to be running.

#+BEGIN_SRC emacs-lisp
(server-start)
#+END_SRC

The other option would be to start emacs as a daemon. can even be started with systemd, see [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Emacs-Server.html][link]].

When calling org capture from outside emacs it uses ~counsel-org-capture~ which has this weird feature that it uses fuzzy matching to determine the template which is unnecessary since all templates have a one-letter abbreviation. Solution: override counsel capture with regular capture.

#+BEGIN_SRC emacs-lisp
(after! org
  (advice-add 'counsel-org-capture :override #'org-capture))
#+END_SRC

** org-notifications

I want notifications for scheduled headlines. Unfortunately ~org-alert~ only has the capability to notify every N minutes and doesn't consider the time an item is scheduled for.

This package sends a notification every x minutes before schedule and even allows for multiple notifications per TODO.


#+BEGIN_SRC emacs-lisp
(use-package! org-wild-notifier
  :after org
  :init
  (add-hook 'doom-after-init-modules-hook #'org-wild-notifier-mode t)
  :config
  (setq org-wild-notifier-alert-time 15
        ;; use dunst for system wide notifications
        alert-default-style 'libnotify))
#+END_SRC
** opening pdfs

I want pdfs to be opened in an external pdf viewer.

#+BEGIN_SRC emacs-lisp
(after! org
  (add-hook 'org-mode-hook
            '(lambda ()
               (delete '("\\.pdf\\'" . default) org-file-apps)
               (add-to-list 'org-file-apps '("\\.pdf\\'" . "zathura %s")))))
#+END_SRC

* LaTeX
** general

#+BEGIN_SRC emacs-lisp
(after! latex
  (setq tex-fontify-script t
        ;; automatically put braces after ^ and _
        TeX-electric-sub-and-superscript nil
        ;; stop asking if I want to save
        TeX-save-query nil
        ;; auto insert second dollar sign
        ;; TeX-electric-math (cons "$" "$")
        ;; don't show ^ or _ for scripts
        font-latex-fontify-script nil)

  ;; use Zathura as pdf viewer
  (setq TeX-view-program-selection '((output-pdf "Zathura"))
        TeX-source-correlate-start-server t))

;; Ensure that synctex works and the pdf is updated.
(after! latex
  (add-hook! 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer))

#+END_SRC

** keybindings

LaTeX specific keybindings.

#+BEGIN_SRC emacs-lisp
(map! :map LaTeX-mode-map
      :localleader
      :desc "Compile" ","  #'TeX-command-run-all
      :desc "Fold"    "z"  #'TeX-fold-buffer
      :desc "ToC"     "t"  #'reftex-toc
      :desc "View"    "v"  #'TeX-view
)
#+END_SRC
** company

#+BEGIN_SRC emacs-lisp
;; (set-company-backend! 'company-reftex-labels  'company-reftex-citations
;;   'company-ispell 'company-capf 'company-files
;;   'company-files 'company-tide 'company-yasnippet)

;; (set-company-backend! 'company-reftex-labels  'company-reftex-citations
;;   'company-ispell 'company-capf 'company-files
;;   'company-files 'company-tide 'company-yasnippet)
;; (after! latex
;;   (set-company-backend! 'latex-mode '(company-latex-commands :with company-yasnippet)))
#+END_SRC
** matchit

add some LaTeX keywords which are not included by ~evil-matchit~ by default.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'evil-matchit-latex
  '(progn
     (push '("langle" nil "rangle") evilmi-latex-match-tags)))
     ;; (push '(("unless" "if") ("elsif" "else") "end"))) evilmi-latex-match-tags)
#+END_SRC

** ~evil-tex~

This package introduces new text objects e.g. ~ci$~ now changes inside $...$.
Always use it when editing tex files:
#+BEGIN_SRC emacs-lisp
(add-hook 'TeX-mode-hook (lambda () (interactive) (evil-tex-mode 1)))
#+END_SRC

* snippets

Snippets are everything!

~yas-keymap~: "The active keymap while a snippet expansion is in progress."

#+BEGIN_SRC emacs-lisp
(after! yasnippet
  (setq yas-snippet-dirs '("~/.doom.d/snippets")
        yas-triggers-in-field t)
  ;; remove random additional newline at the end of new snippets
  (setq-default mode-require-final-newline nil)
  (map! :map yas-minor-mode-map
        :i "C-e" 'yas-expand
        :i "C-f" 'yas-next-field) ;; sometimes I don't want to expand and just go to the next field
  (map! :map yas-keymap "C-e" 'yas-next-field-or-maybe-expand))
#+END_SRC

For some reason ~yas-new-snippet~ cannot guess where to put the snippet (can't guess the mode).
Therefore I'm using ~yas/new-snippet~, although it's obsolete since yasnippet 0.8.
Note that Doom overwrites ~yas-new-snippet~ with ~+snippet/new~. Maybe this is where the problem happens.

#+BEGIN_SRC emacs-lisp
(after! yasnippet
  (map! :leader "s n" 'yas/new-snippet              ;; Snippet New
        ;; :leader "s f" '+snippet/find                ;; Snippet Go
        :leader "s g" 'yas-visit-snippet-file))      ;; Snippet Go
#+END_SRC


** auto expanding

For selected snippets I want them to be automatically expanded (without pressing a trigger key), similarly to what ~abbrev~ already offers (or ~iabbrev~ in vim). However, ~abbrev~ has a super weird syntax.

This code adds this functionality by adding ~#condition: 'auto~ to the header of the snippet.
Code is taken from [[https://github.com/joaotavora/yasnippet/issues/998][a github issue]].

#+BEGIN_SRC emacs-lisp
(defun ab/yas-try-expanding-auto-snippets ()
  (let ((yas-buffer-local-condition ''(require-snippet-condition . auto)))
    (yas-expand)))
(add-hook 'post-command-hook #'ab/yas-try-expanding-auto-snippets)
#+END_SRC
** allow snippets to modify buffer
I added some snippets which modify the buffer by deleting spaces before the snippet. This causes yasnippet to issue warnings.
Remove those warnings:
#+BEGIN_SRC emacs-lisp
(add-to-list 'warning-suppress-types '(yasnippet backquote-change))
#+END_SRC


* syntax checking

#+BEGIN_SRC emacs-lisp
(after! flycheck
;;(flycheck-display-errors-delay .3)
;;(setq-default flycheck-disabled-checkers '(tex-chktex)))
  (map! :leader "a" 'flycheck-next-error))
#+END_SRC

There is a bug in ~chk-tex~, see [[https://github.com/flycheck/flycheck/issues/1214][issue]]. They also describe possible workarounds.

Fixing would be nice too, but apparently this is open, cf. [[https://github.com/flycheck/flycheck/issues/530][issue]].

* R

#+BEGIN_SRC emacs-lisp
;; (use-package ess-smart-underscore
;;   :after ess)
#+END_SRC
* python
** config
#+BEGIN_SRC emacs-lisp
(after! python
  (map! :map python-mode-map
        :localleader "r p" 'run-python
                     "s s" 'python-shell-switch-to-shell
                     "s r" 'python-shell-send-region
                     ","   'python-shell-send-buffer     ; replace C-c C-c
                     "c a" 'conda-env-activate
        ))
#+END_SRC

** fixes
Supposed to fix the
~Warning (python): Your ‘python-shell-interpreter’ doesn’t seem to support readline, yet ‘python-shell-completion-native-enable’ was t and "python3" is not part of the ‘python-shell-completion-native-disabled-interpreters’ list.  Native completions have been disabled locally.~
Warning.
#+BEGIN_SRC emacs-lisp
(after! python
  (setq python-shell-completion-native-enable nil))
#+END_SRC
** conda

I automatically want the right conda environment activated when editing a python file.
How does emacs know which one is the right environment? I don't know..
#+BEGIN_SRC emacs-lisp
(after! conda
  (conda-env-initialize-eshell)
  (conda-env-autoactivate-mode))
#+END_SRC

* auto completion
** company

I used to think =company= is slow, but I just had to turn the ~idle-delay~ down...

#+BEGIN_SRC emacs-lisp
(after! company
  :init
  (setq company-dabbrev-ignore-case t
        company-idle-delay 0.2
        ;; Number the candidates (use M-1, M-2 etc to select completions).
        company-show-numbers t
        company-tooltip-limit 8
        company-tooltip-minimum-width 40
        company-minimum-prefix-length 2)
  (add-hook 'after-init-hook 'global-company-mode)
  :config
  ;; Add yasnippet support for all company backends
  ;; https://github.com/syl20bnr/spacemacs/pull/179
  (defvar company-mode/enable-yas t
    "Enable yasnippet for all backends.")
  (defun company-mode/backend-with-yas (backend)
    (if (or (not company-mode/enable-yas) (and (listp backend) (member 'company-yasnippet backend)))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))
  (setq company-backends (mapcar #'company-mode/backend-with-yas company-backends))

  (map! :i "C-n" 'company-complete)) ;; doesn't work

(map! (:when (featurep! :completion company)
        :i "C-n"      #'+company/complete
        :i "C-SPC"    #'+company/complete))
#+END_SRC

The code chunk in the middle which makes yasnippet work with company is taken from [[https://emacs.stackexchange.com/questions/10431/get-company-to-show-suggestions-for-yasnippet-names][stackexchange]]. How can people live without this?? Also for some reason it has to be inside the entire thing even if company is not defered (no idea why).

** company-backends

For some reason it is super hard to get ~company-backends~ right...
This is copied from [[https://www.gtrun.org/post/init/#org-mode][here]].

#+BEGIN_SRC emacs-lisp
;; (set-company-backend! '(c-mode
;;                         ess-mode
;;                         emacs-lisp-mode
;;                         elisp-mode
;;                         latex-mode
;;                         tex-mode
;;                         lisp-mode
;;                         sh-mode
;;                         python-mode
;;                         )
;;   '(:separate  company-tabnine
;;                company-files
;;                company-capf
;;                company-yasnippet))

;; (setq +lsp-company-backend '(company-lsp :with company-tabnine :separate))
#+END_SRC

* spell checking

As the name suggests. According to [[https://fasciism.com/2017/01/16/spellchecking/][this site]] Aspell is unmaintained and Hunspell is the way to go.

Default binding: ~z =~ for suggestions on how to correct the word.

#+BEGIN_SRC emacs-lisp
(after! flyspell
  :config
  (map! :leader "s c" 'flyspell-mode)      ;; toggle spell checking
  (map! :n "z=" 'ispell-word)

  (setq ispell-program-name "hunspell"
        ispell-silently-savep t            ;; save persal dictionary without asking
        ispell-local-dictionary "en_US"
        ;; ispell-extra-args '("--sug-mode=ultra" "--lang=en_US")
        ispell-list-command "--list"
        ispell-local-dictionary-alist '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "['‘’]"
                                         t ; Many other characters
                                         ("-d" "en_US") nil utf-8))))
#+END_SRC

vim has a command for directly adding new words to dictionary. I want this.

#+BEGIN_SRC emacs-lisp
(defun ab/save-word ()
  (interactive)
  (let ((current-location (point))
        (word (flyspell-get-word)))
    (when (consp word)
      (flyspell-do-correct 'save nil (car word) current-location (cadr word) (caddr word) current-location))))

(map! :n "z g" 'ab/save-word)
#+END_SRC

* fuzzy matching

The ~counsel~ package installs all three of them. ~Swiper~ is just the fancy
search. ~Ivy~ does the narrowing. ~counsel~ adds options to ~Ivy~

#+BEGIN_SRC emacs-lisp
(after! ivy
  (map! "C-s" 'counsel-grep-or-swiper)
  ;; Virtual buffers correspond to bookmarks and recent files list
  (setq ivy-use-virtual-buffers t))
#+END_SRC

* auto closing of parenthesis

Smart treatment of parenthesis, like auto closing or auto deletion of the matching one.

#+BEGIN_SRC emacs-lisp
(after! smartparens
  (sp-local-pair 'org-mode "$" "$")
  ;; (sp-local-pair 'latex-mode "$" "$")   ;; omg, I want this so badly
  (sp-local-pair 'latex-mode "\\langle" "\\rangle" :trigger "\\lan")
  (sp-local-pair 'latex-mode "\\lVert" "\\rVert" :trigger "\\lVe")

  (sp-local-pair 'latex-mode "\\left(" "\\right)" :trigger "\\(")
  (sp-local-pair 'latex-mode "\\left[" "\\right]" :trigger "\\l[")
  (sp-local-pair 'latex-mode "\\left\\{" "\\right\\}" :trigger "\\l{")
  (sp-local-pair 'latex-mode "\\left\\langle" "\\right\\rangle" :trigger "\\left\\la")

  (smartparens-global-mode 1)) ;; I always want this
#+END_SRC

* mail

** mu4e config

#+BEGIN_SRC emacs-lisp
(after! mu4e
  (setq +mu4e-backend 'offlineimap)
  (setq mu4e-maildir "~/.mail"))
#+END_SRC

Convenience function for starting the whole mu4e in its own frame.
Posted by the author of mu4e on the mailing list.

#+BEGIN_SRC emacs-lisp
(defun mu4e-in-new-frame ()
  "Start mu4e in new frame."
  (interactive)
  (select-frame (make-frame))
  (mu4e))
#+END_SRC
** univie mailbox

#+BEGIN_SRC emacs-lisp
(after! mu4e
  ;; Each path is relative to `+mu4e-mu4e-mail-path', which is ~/.mail by default
  (set-email-account! "uniwien"
                      '((user-full-name        . "Axel Böhm")
                        (user-mail-address      . "axel.boehm@univie.ac.at")
                        (smtpmail-smtp-user     . "boehma53@univie.ac.at")

                        (mu4e-sent-folder       . "/uniwien/INBOX.Sent/")
                        (mu4e-drafts-folder     . "/uniwien/INBOX.Drafts")
                        (mu4e-trash-folder      . "/uniwien/INBOX.Trash")
                        (mu4e-refile-folder     . "/uniwien/INBOX.Archive")
                        (smtpmail-smtp-server   . "mail.unvie.ac.at")
                        (smtpmail-smtp-service  .  587)
                        (mu4e-compose-signature . "---\nAxel Boehm"))
                      t)

  ;; use mu4e for e-mail in emacs
  (setq mail-user-agent 'mu4e-user-agent)
  ;; (Setq mu4e-sent-messages-behavior 'delete)

  ;; allow for updating mail using 'U' in the main view:
  ;; (setq mu4e-get-mail-command "offlineimap") )
  )
#+END_SRC

** ymail.

#+BEGIN_SRC emacs-lisp
(after! mu4e
  (set-email-account! "ymail"
    `((mu4e-sent-folder       . "/ymail/Sent")
      (mu4e-drafts-folder     . "/ymail/Drafts")
      (mu4e-trash-folder      . "/ymail/Trash")
      (mu4e-refile-folder     . "/ymail/Archive")
      ;; (smtpmail-smtp-user     . ,(auth-source-pass-get "user" "mail/mainmail"))
      ;; (user-mail-address      . ,(auth-source-pass-get "user" "mail/mainmail"))
      (mu4e-compose-signature . "---\nAxel Boehm"))))
#+END_SRC


still to do

** contacts

#+BEGIN_SRC emacs-lisp
;; (use-package! org-contacts
;;   :after org
;;   :custom (org-contacts-files '("~/documents/contacts.org")))

;; (setq mu4e-org-contacts-file (car org-contacts-files))
;; (add-to-list 'mu4e-headers-actions
;;              '("org-contact-add" . mu4e-action-add-org-contact) t)
;; (add-to-list 'mu4e-view-actions
;;              '("org-contact-add" . mu4e-action-add-org-contact) t)
#+END_SRC

* dired

I'm so used to my ranger keybindings. Imitate those:

#+BEGIN_SRC emacs-lisp
(map! :map dired-mode
      "h" 'dired-up-directory)
#+END_SRC

* pdf

Navigate pdfs the way I'm used to.

#+BEGIN_SRC emacs-lisp
;; Use the usual C-u/C-d keybindings to navigate pdfs.
(map!
 :map pdf-view-mode-map
 :m "C-u" 'pdf-view-scroll-down-or-previous-page
 :m "C-d" 'pdf-view-scroll-up-or-next-page)

#+END_SRC

* ~avy~

** keys being used :colemak:

~avy~ uses the qwerty home row by default. Change this.

#+BEGIN_SRC emacs-lisp
(setq avy-keys '(?a ?r ?s ?t ?d ?h ?n ?e ?i ?o))
#+END_SRC
